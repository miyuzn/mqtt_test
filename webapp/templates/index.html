<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Real-Time Pressure Monitor</title>

    <!-- Bootstrap (local) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='vendor/bootstrap/bootstrap.min.css') }}" />

    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
    <style>
      .device-panel-card {
        transition: all 0.2s;
      }
      .cop-section.hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <!-- Main dashboard wrapper -->
    <div class="container py-4">
      <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
        <div>
          <h1 class="h3 mb-1" data-i18n="header.title">Real-Time Pressure Dashboard</h1>
        </div>
        <div class="text-md-end">
          <div class="btn-group btn-group-sm language-switcher mb-2" role="group" id="language-switcher">
            <button type="button" class="btn btn-outline-secondary" data-lang="ja">日本語</button>
            <button type="button" class="btn btn-outline-secondary" data-lang="en">English</button>
            <button type="button" class="btn btn-outline-secondary" data-lang="zh">中文</button>
          </div>
          <div class="badge bg-secondary d-block" id="status-indicator" data-i18n="status.connecting">Connecting...</div>
          <div class="small text-muted" id="last-update">--</div>
        </div>
      </div>
  
      <!-- Global Controls -->
      <div class="card shadow-sm mb-4">
        <div class="card-body">
          <div class="row g-3 align-items-center">
            <div class="col-12 col-md-auto">
                <h2 class="h6 mb-0" data-i18n="heatmap.heading">Pressure Heatmap</h2>
            </div>
            <div class="col-12 col-md-auto border-start ps-md-3">
              <button class="btn btn-sm btn-primary" id="add-panel-btn">
                <span data-i18n="actions.add_panel">+ Add Device View</span>
              </button>
            </div>
            <div class="col-12 col-md-auto border-start ps-md-3 d-flex gap-2">
                <button class="btn btn-sm btn-outline-danger" id="global-record-start" title="Start Recording All">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-record-circle" viewBox="0 0 16 16">
                      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                      <path d="M11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/>
                    </svg>
                    <span class="d-none d-lg-inline ms-1" data-i18n="actions.record_all_start">Rec All</span>
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="global-record-stop" title="Stop Recording All">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop-circle" viewBox="0 0 16 16">
                      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                      <path d="M5 6.5A1.5 1.5 0 0 1 6.5 5h3A1.5 1.5 0 0 1 11 6.5v3A1.5 1.5 0 0 1 9.5 11h-3A1.5 1.5 0 0 1 5 9.5v-3z"/>
                    </svg>
                    <span class="d-none d-lg-inline ms-1" data-i18n="actions.record_all_stop">Stop All</span>
                </button>
            </div>
            <div class="col-12 col-md-auto">
                <div class="form-check form-switch mb-0">
                  <input class="form-check-input" type="checkbox" id="cop-toggle" checked />
                  <label class="form-check-label" for="cop-toggle" data-i18n="controls.show_cop">Show COP</label>
                </div>
            </div>
            
            <div class="col-12 border-top my-2 d-md-none"></div>

            <!-- Pressure Range -->
             <div class="col-12 col-md-auto ms-md-auto d-flex align-items-center gap-2">
                <span class="text-secondary small fw-semibold text-nowrap" data-i18n="controls.range">Range</span>
                <div class="input-group input-group-sm" style="max-width: 140px;">
                    <span class="input-group-text">Min</span>
                    <input type="number" class="form-control" id="pressure-min" value="300" placeholder="Min">
                </div>
                <div class="input-group input-group-sm" style="max-width: 140px;">
                    <span class="input-group-text">Max</span>
                    <input type="number" class="form-control" id="pressure-max" value="1000" placeholder="Max">
                </div>
                <button class="btn btn-sm btn-outline-secondary" type="button" id="reset-range" data-i18n="actions.reset">Reset</button>
             </div>
          </div>
        </div>
      </div>

      <!-- Panels Container -->
      <div class="row g-4" id="panels-container">
         <!-- Dynamic panels injected here -->
      </div>

      <!-- Device table -->
      <div class="card shadow-sm mt-4">
        <div class="card-body">
          <h2 class="h5 mb-3" data-i18n="table.title">Device Details</h2>
          <div class="table-responsive" style="max-height: 360px;">
            <table class="table table-striped align-middle" id="device-table">
              <thead class="table-light sticky-top">
                <tr>
                  <th scope="col" data-i18n="table.headers.dn">DN</th>
                  <th scope="col" data-i18n="table.headers.count">Sensors</th>
                  <th scope="col" data-i18n="table.headers.frame_time">Latest Frame</th>
                  <th scope="col" data-i18n="table.headers.receive_time">Received At</th>
                  <th scope="col" class="text-center" data-i18n="table.headers.actions">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Template for Device Panel -->
    <template id="panel-template">
        <div class="col-12 col-xl-6 device-panel-wrapper">
            <div class="card shadow-sm h-100 device-panel-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h3 class="h6 mb-0 js-panel-title" data-i18n="controls.device">Device</h3>
                        <div class="d-flex gap-2">
                            <button class="btn btn-sm btn-outline-danger js-record-btn" aria-label="Record" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-record-circle" viewBox="0 0 16 16">
                                  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                                  <path d="M11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/>
                                </svg>
                            </button>
                            <button class="btn btn-sm btn-outline-danger js-remove-panel-btn" aria-label="Remove">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
                                    <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div class="heatmap-panel-controls">
                        <div class="input-group mb-2">
                            <span class="input-group-text" data-i18n="controls.device">Device</span>
                            <select class="form-select js-device-selector">
                                <option value="" data-i18n="controls.waiting">Waiting...</option>
                            </select>
                        </div>
                        <div class="input-group mb-2">
                            <span class="input-group-text" data-i18n="controls.layout">Layout</span>
                            <select class="form-select js-layout-selector" disabled>
                                <option value="">--</option>
                            </select>
                        </div>
                        <div class="mirror-toggle-group d-flex flex-wrap align-items-center gap-3">
                            <div class="form-check form-switch mb-0">
                                <input class="form-check-input js-mirror-rows" type="checkbox" />
                                <label class="form-check-label" data-i18n="controls.mirror_rows">Row Mirror</label>
                            </div>
                            <div class="form-check form-switch mb-0">
                                <input class="form-check-input js-mirror-cols" type="checkbox" />
                                <label class="form-check-label" data-i18n="controls.mirror_cols">Col Mirror</label>
                            </div>
                        </div>
                    </div>

                    <div class="heatmap-wrapper js-heatmap-container">
                        <div class="heatmap-placeholder" data-i18n="heatmap.empty.waiting">Waiting...</div>
                    </div>

                    <div class="device-metrics">
                        <div class="device-sensor-grid">
                            <div class="overview-sensor-block">
                                <div class="fw-semibold" data-i18n="overview.gyro">Gyro (°/s)</div>
                                <div class="sensor-vector">
                                    <div class="axis-value"><span>X</span><strong class="js-gyro-x">--</strong></div>
                                    <div class="axis-value"><span>Y</span><strong class="js-gyro-y">--</strong></div>
                                    <div class="axis-value"><span>Z</span><strong class="js-gyro-z">--</strong></div>
                                </div>
                            </div>
                            <div class="overview-sensor-block">
                                <div class="fw-semibold" data-i18n="overview.acc">Acc (m/s²)</div>
                                <div class="sensor-vector">
                                    <div class="axis-value"><span>X</span><strong class="js-acc-x">--</strong></div>
                                    <div class="axis-value"><span>Y</span><strong class="js-acc-y">--</strong></div>
                                    <div class="axis-value"><span>Z</span><strong class="js-acc-z">--</strong></div>
                                </div>
                            </div>
                        </div>
                        <div class="overview-sensor-block mt-3 cop-section js-cop-section">
                            <div class="fw-semibold" data-i18n="overview.cop">COP</div>
                            <div class="cop-board js-cop-board">
                                <div class="cop-board-placeholder js-cop-placeholder" data-i18n="overview.cop_empty">Waiting...</div>
                                <div class="cop-dot js-cop-dot"></div>
                            </div>
                            <div class="row text-center cop-values mt-3">
                                <div class="col">
                                    <div class="text-muted small" data-i18n="overview.cop_x">X</div>
                                    <div class="fw-semibold js-cop-x">--</div>
                                </div>
                                <div class="col">
                                    <div class="text-muted small" data-i18n="overview.cop_y">Y</div>
                                    <div class="fw-semibold js-cop-y">--</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <script type="module">
      import * as THREE from "{{ url_for('static', filename='vendor/three/three.module.js') }}";
      import { OrbitControls } from "{{ url_for('static', filename='vendor/three/OrbitControls.js') }}";

      window.THREE = THREE;
      window.OrbitControls = OrbitControls;
      window.__three_ready = true;
      window.dispatchEvent(new Event("three-ready"));
    </script>
    <script>
      const SNAPSHOT_ENDPOINT = "{{ url_for('proxy_latest') }}";
      const STREAM_ENDPOINT = "{{ url_for('proxy_stream') }}";

      const state = new Map();
      const mirrorSettingsByDevice = new Map();
      const recordingStateByDevice = new Map();
      const STALE_THRESHOLD_MS = 30 * 1000;
      
      // Dynamic Panels Management
      const panelsContainer = document.getElementById("panels-container");
      const panelTemplate = document.getElementById("panel-template");
      let panels = [];
      let panelIdCounter = 0;
      let copVisible = true;

      const pressureMinInput = document.getElementById("pressure-min");
      const pressureMaxInput = document.getElementById("pressure-max");
      const resetRangeButton = document.getElementById("reset-range");
      const statusIndicator = document.getElementById("status-indicator");
      const activeDevicesLabel = document.getElementById("active-devices"); // might not exist in new layout
      const lastUpdateLabel = document.getElementById("last-update");
      const languageButtons = document.querySelectorAll("#language-switcher [data-lang]");
      const addPanelBtn = document.getElementById("add-panel-btn");
      const copToggle = document.getElementById("cop-toggle");
      const globalRecordStartBtn = document.getElementById("global-record-start");
      const globalRecordStopBtn = document.getElementById("global-record-stop");

      const panelRenderCache = new Map();
      const DEFAULT_RANGE_MIN = 300;
      const DEFAULT_RANGE_MAX = 1000;
      let customRangeMin = DEFAULT_RANGE_MIN;
      let customRangeMax = DEFAULT_RANGE_MAX;
      const REFRESH_INTERVAL_MS = 33;
      const SURFACE_LOOP_IDLE_MS = 500;
      let surfaceLoopRafId = null;
      let surfaceLoopActiveUntil = 0;
      let surfaceDirty = false;
      const SNAPSHOT_POLL_INTERVAL_MS = 30000;
      const STREAM_RECONNECT_BASE_DELAY_MS = 2000;
      const STREAM_RECONNECT_MAX_DELAY_MS = 15000;
      let pendingRefresh = false;
      let refreshTimerId = null;
      let lastRefreshTimestamp = 0;
      let snapshotPollTimerId = null;
      let currentEventSource = null;
      let streamReconnectTimerId = null;
      let streamReconnectAttempts = 0;

      // Translations
      const LANGUAGE_META = {
        zh: { locale: "zh-CN" },
        ja: { locale: "ja-JP" },
        en: { locale: "en" }
      };

      const TRANSLATIONS = {
        zh: {
          "page.title": "实时压力监控面板",
          "header.title": "实时压力监控面板",
          "header.data_source": "数据来源：",
          "status.connecting": "连接中...",
          "status.snapshot_ok": "已连接",
          "status.snapshot_error": "桥接不可用",
          "status.stream_error": "实时连接中断",
          "status.stream_ok": "实时连接已建立",
          "heatmap.heading": "压力热力图",
          "controls.device": "设备",
          "controls.layout": "布局",
          "controls.mirror_rows": "行镜像",
          "controls.mirror_cols": "列镜像",
          "controls.range": "压力范围",
          "controls.waiting": "等待数据...",
          "controls.show_cop": "显示 COP",
          "actions.add_panel": "+ 添加设备视图",
          "actions.record_all_start": "全部录制",
          "actions.record_all_stop": "停止录制",
          "actions.reset": "重置",
          "overview.gyro": "陀螺仪 (°/s)",
          "overview.acc": "加速度 (m/s²)",
          "overview.cop": "压力中心 (COP)",
          "overview.cop_x": "X 坐标",
          "overview.cop_y": "Y 坐标",
          "overview.cop_empty": "等待设备数据...",
          "table.title": "设备详情",
          "table.headers.dn": "DN",
          "table.headers.count": "压力传感器数",
          "table.headers.frame_time": "最新帧时间",
          "table.headers.receive_time": "接收时间",
          "table.headers.actions": "操作",
          "table.actions.stop_tracking": "停止追踪",
          "heatmap.empty.no_device": "选择设备以查看压力热力图",
          "heatmap.empty.no_layout": "请选择布局组合",
          "heatmap.empty.waiting": "等待设备数据更新...",
          "console.snapshot_fetch_failed": "无法获取数据",
        },
        ja: {
          "page.title": "リアルタイム圧力モニター",
          "header.title": "リアルタイム圧力モニター",
          "header.data_source": "データソース：",
          "status.connecting": "接続中...",
          "status.snapshot_ok": "スナップショットを取得",
          "status.snapshot_error": "ブリッジに接続できません",
          "status.stream_error": "リアルタイム接続が中断しました",
          "status.stream_ok": "リアルタイム接続が確立されました",
          "heatmap.heading": "圧力ヒートマップ",
          "controls.device": "デバイス",
          "controls.layout": "レイアウト",
          "controls.mirror_rows": "行を反転",
          "controls.mirror_cols": "列を反転",
          "controls.range": "圧力範囲",
          "controls.waiting": "データ待機中...",
          "controls.show_cop": "COPを表示",
          "actions.add_panel": "+ デバイス表示を追加",
          "actions.record_all_start": "全録画開始",
          "actions.record_all_stop": "全録画停止",
          "actions.reset": "リセット",
          "overview.gyro": "ジャイロ (°/s)",
          "overview.acc": "加速度 (m/s²)",
          "overview.cop": "圧力中心 (COP)",
          "overview.cop_x": "X 座標",
          "overview.cop_y": "Y 座標",
          "overview.cop_empty": "デバイスのデータを待機中...",
          "table.title": "デバイス詳細",
          "table.headers.dn": "DN",
          "table.headers.count": "センサー数",
          "table.headers.frame_time": "最新フレーム時刻",
          "table.headers.receive_time": "受信時刻",
          "table.headers.actions": "操作",
          "table.actions.stop_tracking": "監視を停止",
          "heatmap.empty.no_device": "デバイスを選択してヒートマップを表示",
          "heatmap.empty.no_layout": "レイアウトを選択してください",
          "heatmap.empty.waiting": "デバイスデータの更新を待機中...",
          "console.snapshot_fetch_failed": "データを取得できませんでした",
        },
        en: {
          "page.title": "Real-Time Pressure Dashboard",
          "header.title": "Real-Time Pressure Dashboard",
          "header.data_source": "Data source: ",
          "status.connecting": "Connecting...",
          "status.snapshot_ok": "Snapshot loaded",
          "status.snapshot_error": "Bridge unavailable",
          "status.stream_error": "Realtime feed interrupted",
          "status.stream_ok": "Realtime feed active",
          "heatmap.heading": "Pressure Heatmap",
          "controls.device": "Device",
          "controls.layout": "Layout",
          "controls.mirror_rows": "Mirror rows",
          "controls.mirror_cols": "Mirror columns",
          "controls.range": "Pressure range",
          "controls.waiting": "Waiting for data...",
          "controls.show_cop": "Show COP",
          "actions.add_panel": "+ Add Device View",
          "actions.record_all_start": "Rec All",
          "actions.record_all_stop": "Stop All",
          "actions.reset": "Reset",
          "overview.gyro": "Gyroscope (°/s)",
          "overview.acc": "Acceleration (m/s²)",
          "overview.cop": "Center of Pressure (COP)",
          "overview.cop_x": "X coordinate",
          "overview.cop_y": "Y coordinate",
          "overview.cop_empty": "Waiting for device data...",
          "table.title": "Device Details",
          "table.headers.dn": "DN",
          "table.headers.count": "Sensor count",
          "table.headers.frame_time": "Latest frame time",
          "table.headers.receive_time": "Received at",
          "table.headers.actions": "Actions",
          "table.actions.stop_tracking": "Stop tracking",
          "heatmap.empty.no_device": "Select a device to view the heatmap",
          "heatmap.empty.no_layout": "Choose a layout",
          "heatmap.empty.waiting": "Waiting for device data...",
          "console.snapshot_fetch_failed": "Failed to fetch data",
        }
      };

      let currentLanguage = localStorage.getItem("uiLanguage") || "ja";
      if (!Object.prototype.hasOwnProperty.call(TRANSLATIONS, currentLanguage)) {
        currentLanguage = "ja";
      }
      let currentStatusKey = "connecting";

      // --- Helper Functions ---

      function t(key) {
        const pack = TRANSLATIONS[currentLanguage] || TRANSLATIONS.ja;
        return pack[key] || TRANSLATIONS.ja[key] || key;
      }

      function updateStatusIndicatorText() {
        if (!statusIndicator) return;
        statusIndicator.textContent = t(`status.${currentStatusKey}`);
      }

      function setStatusIndicator(stateKey) {
        currentStatusKey = stateKey;
        updateStatusIndicatorText();
      }

      function applyLanguage() {
        const locale = LANGUAGE_META[currentLanguage]?.locale || "ja-JP";
        document.documentElement.lang = locale;
        document.title = t("page.title");
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.dataset.i18n;
          if (key && t(key)) el.textContent = t(key);
        });
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.dataset.i18nPlaceholder;
          if (key && t(key)) el.setAttribute("placeholder", t(key));
        });
        updateStatusIndicatorText();
        updateLanguageSwitcherState();
        updateRangePlaceholders(null, null);
        
        // Refresh panel layouts to update language in options
        panels.forEach(p => updateLayoutOptionsForPanel(p));
        updateDeviceOptions(); 
      }

      function setLanguage(lang) {
        if (!TRANSLATIONS[lang]) return;
        currentLanguage = lang;
        localStorage.setItem("uiLanguage", lang);
        applyLanguage();
        refreshUI();
      }

      function updateLanguageSwitcherState() {
        languageButtons.forEach((button) => {
          const isActive = button.dataset.lang === currentLanguage;
          button.classList.toggle("btn-primary", isActive);
          button.classList.toggle("btn-outline-secondary", !isActive);
        });
      }
      
      languageButtons.forEach((button) => {
        button.addEventListener("click", () => setLanguage(button.dataset.lang));
      });

      // --- Dynamic Panel Logic ---

      function createPanel() {
        panelIdCounter++;
        const key = `panel-${panelIdCounter}`;
        const fragment = panelTemplate.content.cloneNode(true);
        const root = fragment.querySelector('.device-panel-wrapper');
        
        const panel = {
            key,
            rootElement: root,
            deviceSelector: root.querySelector('.js-device-selector'),
            layoutSelector: root.querySelector('.js-layout-selector'),
            heatmapContainer: root.querySelector('.js-heatmap-container'),
            mirrorRowsToggle: root.querySelector('.js-mirror-rows'),
            mirrorColsToggle: root.querySelector('.js-mirror-cols'),
            removeBtn: root.querySelector('.js-remove-panel-btn'),
            recordBtn: root.querySelector('.js-record-btn'),
            copSection: root.querySelector('.js-cop-section'),
            copBoard: root.querySelector('.js-cop-board'),
            copDot: root.querySelector('.js-cop-dot'),
            copPlaceholder: root.querySelector('.js-cop-placeholder'),
            copXValue: root.querySelector('.js-cop-x'),
            copYValue: root.querySelector('.js-cop-y'),
            gyroElements: {
                x: root.querySelector('.js-gyro-x'),
                y: root.querySelector('.js-gyro-y'),
                z: root.querySelector('.js-gyro-z')
            },
            accElements: {
                x: root.querySelector('.js-acc-x'),
                y: root.querySelector('.js-acc-y'),
                z: root.querySelector('.js-acc-z')
            },
            selectedDevice: null,
            selectedLayoutKey: null,
            mirrorRows: false,
            mirrorCols: false,
            deviceOptionsCache: { devices: [], selected: null, lang: null },
            layoutOptionsCache: { dn: null, sensorCount: null, options: [], selectedKey: null, lang: null },
            three: null
        };

        // Event Listeners
        panel.removeBtn.addEventListener('click', () => removePanel(panel));
        
        if (panel.recordBtn) {
            panel.recordBtn.addEventListener('click', () => {
                if (!panel.selectedDevice) return;
                const currentState = recordingStateByDevice.get(panel.selectedDevice) || false;
                toggleRecord(panel.selectedDevice, !currentState);
            });
        }
        
        panel.deviceSelector.addEventListener('change', (e) => {
            panel.selectedDevice = e.target.value || null;
            panel.deviceOptionsCache.selected = panel.selectedDevice;
            syncPanelMirrorControls(panel);
            updateLayoutOptionsForPanel(panel);
            updatePanelSensors(panel);
            updateAllHeatmaps();
            updatePanelCop(panel);
            updatePanelRecordingState(panel);
        });

        panel.layoutSelector.addEventListener('change', (e) => {
            panel.selectedLayoutKey = e.target.value || null;
            panel.layoutOptionsCache.selectedKey = panel.selectedLayoutKey;
            updateAllHeatmaps();
            updatePanelCop(panel);
        });

        panel.mirrorRowsToggle.addEventListener('change', (e) => {
            panel.mirrorRows = Boolean(e.target.checked);
            persistMirrorSettings(panel);
            updateAllHeatmaps();
        });

        panel.mirrorColsToggle.addEventListener('change', (e) => {
            panel.mirrorCols = Boolean(e.target.checked);
            persistMirrorSettings(panel);
            updateAllHeatmaps();
        });

        panelsContainer.appendChild(root);
        panels.push(panel);
        
        // Initial state
        applyCOPStateToPanel(panel);
        updateDeviceOptions();
        updateLayoutOptionsForPanel(panel);
        updatePanelRecordingState(panel);
        
        return panel;
      }

      function removePanel(panelToRemove) {
        if (panels.length <= 1) {
            // Optional: prevent removing the last panel, or allow it but show empty state?
            // For now, let's allow it but maybe auto-add one if empty?
            // User requested "upgrade", let's keep it flexible.
        }
        
        // Cleanup Three.js
        if (panelToRemove.three) {
            if (panelToRemove.three.geometry) panelToRemove.three.geometry.dispose();
            if (panelToRemove.three.material) panelToRemove.three.material.dispose();
            panelToRemove.three.renderer.dispose();
            panelToRemove.three = null;
        }

        panelToRemove.rootElement.remove();
        panels = panels.filter(p => p !== panelToRemove);
        panelRenderCache.delete(panelToRemove.key);
      }

      function applyCOPStateToPanel(panel) {
          if (copVisible) {
              panel.copSection.classList.remove('hidden');
          } else {
              panel.copSection.classList.add('hidden');
          }
      }

      addPanelBtn.addEventListener('click', () => {
          createPanel();
      });

      copToggle.addEventListener('change', (e) => {
          copVisible = e.target.checked;
          panels.forEach(applyCOPStateToPanel);
      });

      if (globalRecordStartBtn) {
          globalRecordStartBtn.addEventListener('click', () => toggleRecord("ALL", true));
      }
      if (globalRecordStopBtn) {
          globalRecordStopBtn.addEventListener('click', () => toggleRecord("ALL", false));
      }

      async function toggleRecord(dn, shouldRecord) {
          try {
              const resp = await fetch("/api/record", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ dn: dn, record: shouldRecord })
              });
              if (!resp.ok) throw new Error(`API Error: ${resp.status}`);
              
              if (dn === "ALL") {
                  // Optimistically update all known devices
                  const allDns = Array.from(state.keys());
                  allDns.forEach(d => recordingStateByDevice.set(d, shouldRecord));
              } else {
                  recordingStateByDevice.set(dn, shouldRecord);
              }
              // Refresh UI
              panels.forEach(updatePanelRecordingState);
          } catch (err) {
              console.error("Failed to toggle record:", err);
              alert("Failed to toggle recording. Check console/logs.");
          }
      }

      // Initialize with 2 panels to mimic old dual mode, or 1?
      // Old mode had 2 panels, but 2nd was hidden by default.
      // Let's start with 2 panels visible for "Multi-Device Mode" feel.
      createPanel();
      createPanel();

      // --- Heatmap & Render Logic ---

      const COLOR_GREEN = [46, 204, 113];
      const COLOR_YELLOW = [241, 196, 15];
      const COLOR_ORANGE = [243, 156, 18];
      const COLOR_RED = [231, 76, 60];
      const GRADIENT_STOPS = [
        { stop: 0, color: COLOR_GREEN },
        { stop: 0.33, color: COLOR_YELLOW },
        { stop: 0.66, color: COLOR_ORANGE },
        { stop: 1, color: COLOR_RED }
      ];

      function computeFactorPairs(sn) {
        if (!Number.isInteger(sn) || sn <= 0) return [];
        const basePairs = [];
        const limit = Math.floor(Math.sqrt(sn));
        for (let i = 1; i <= limit; i += 1) {
          if (sn % i === 0) basePairs.push([i, sn / i]);
        }
        const pairs = [];
        basePairs.forEach(([rows, cols]) => {
          if (rows <= 12 && cols <= 12) {
            pairs.push([rows, cols]);
          }
          if (rows !== cols && cols <= 12 && rows <= 12) {
            pairs.push([cols, rows]);
          }
        });
        pairs.sort((a, b) => {
          const diffA = Math.abs(a[0] - a[1]);
          const diffB = Math.abs(b[0] - b[1]);
          if (diffA !== diffB) return diffA - diffB;
          return a[0] - b[0];
        });
        return pairs;
      }

      function chooseDefaultLayout(pairs) {
        if (!pairs.length) return null;
        return `${pairs[0][0]}x${pairs[0][1]}`;
      }

      function parseLayoutKey(key) {
        if (!key) return null;
        const [rows, cols] = key.split("x").map(Number);
        if (!Number.isInteger(rows) || !Number.isInteger(cols)) return null;
        return [rows, cols];
      }

      function handleCustomRangeChange() {
        if (!pressureMinInput || !pressureMaxInput) return;
        const rawMin = pressureMinInput.value.trim();
        const rawMax = pressureMaxInput.value.trim();
        const minValue = Number(rawMin);
        const maxValue = Number(rawMax);
        const minValid = rawMin === "" || Number.isFinite(minValue);
        const maxValid = rawMax === "" || Number.isFinite(maxValue);

        pressureMinInput.classList.remove("is-invalid");
        pressureMaxInput.classList.remove("is-invalid");

        if (!minValid || !maxValid) {
          if (!minValid) pressureMinInput.classList.add("is-invalid");
          if (!maxValid) pressureMaxInput.classList.add("is-invalid");
          customRangeMin = null;
          customRangeMax = null;
        } else if (rawMin !== "" && rawMax !== "") {
          if (minValue < maxValue) {
            customRangeMin = minValue;
            customRangeMax = maxValue;
          } else {
             pressureMinInput.classList.add("is-invalid");
             pressureMaxInput.classList.add("is-invalid");
             customRangeMin = null;
             customRangeMax = null;
          }
        } else {
           customRangeMin = null;
           customRangeMax = null;
        }
        updateAllHeatmaps();
        requestSurfaceRefresh();
      }
      
      if (pressureMinInput && pressureMaxInput) {
          ["input", "change"].forEach(ev => {
              pressureMinInput.addEventListener(ev, handleCustomRangeChange);
              pressureMaxInput.addEventListener(ev, handleCustomRangeChange);
          });
      }
      
      if (resetRangeButton) {
          resetRangeButton.addEventListener('click', () => {
              if (pressureMinInput) pressureMinInput.value = DEFAULT_RANGE_MIN;
              if (pressureMaxInput) pressureMaxInput.value = DEFAULT_RANGE_MAX;
              customRangeMin = DEFAULT_RANGE_MIN;
              customRangeMax = DEFAULT_RANGE_MAX;
              handleCustomRangeChange();
          });
      }

      function updateRangePlaceholders(dataMin, dataMax) {
        if (pressureMinInput) {
          pressureMinInput.placeholder = Number.isFinite(dataMin) ? dataMin : "Min";
        }
        if (pressureMaxInput) {
          pressureMaxInput.placeholder = Number.isFinite(dataMax) ? dataMax : "Max";
        }
      }

      function resolveEffectiveRange(dataMin, dataMax) {
        if (Number.isFinite(customRangeMin) && Number.isFinite(customRangeMax) && customRangeMin < customRangeMax) {
          return { min: customRangeMin, max: customRangeMax };
        }
        if (Number.isFinite(dataMin) && Number.isFinite(dataMax)) {
          return { min: dataMin, max: dataMax };
        }
        return { min: 0, max: 0 };
      }

      // --- Three.js Surface Logic ---
      const SURFACE_SUBDIV = 8;
      const SURFACE_HEIGHT_FRACTION = 0.35;
      const SURFACE_LUT_SIZE = 256;
      const SURFACE_MISSING_RGB = [0.87, 0.89, 0.90];

      function buildGradientLut(stops, size) {
        const lut = new Float32Array(size * 3);
        if (!Array.isArray(stops) || stops.length < 2 || size <= 1) return lut;
        for (let i = 0; i < size; i++) {
          const ratio = i / (size - 1);
          let r=0, g=0, b=0;
          for (let s=1; s<stops.length; s++) {
             if (ratio <= stops[s].stop) {
                const prev = stops[s-1], next = stops[s];
                const t = (ratio - prev.stop) / (next.stop - prev.stop || 1);
                r = prev.color[0] + (next.color[0]-prev.color[0])*t;
                g = prev.color[1] + (next.color[1]-prev.color[1])*t;
                b = prev.color[2] + (next.color[2]-prev.color[2])*t;
                break;
             }
          }
          lut[i*3] = r/255; lut[i*3+1] = g/255; lut[i*3+2] = b/255;
        }
        return lut;
      }
      const SURFACE_GRADIENT_LUT = buildGradientLut(GRADIENT_STOPS, SURFACE_LUT_SIZE);

      function threeIsAvailable() {
        return Boolean(window.THREE && window.THREE.WebGLRenderer && window.OrbitControls);
      }
      
      function buildSurfaceGeometry(rows, cols, subdiv) {
          // (Same geometry logic as before, simplified for brevity in thought, but full in code)
          // I will copy the original implementation to ensure correctness
          const safeRows = Math.max(1, rows);
          const safeCols = Math.max(1, cols);
          const steps = Math.max(0, Number.isInteger(subdiv) ? subdiv : 0);
          const segments = steps + 1;
          const fineCols = (safeCols - 1) * segments + 1;
          const fineRows = (safeRows - 1) * segments + 1;
          const fineW = Math.max(0, fineCols - 1);
          const fineH = Math.max(0, fineRows - 1);
          const sensorW = Math.max(0, safeCols - 1);
          const sensorH = Math.max(0, safeRows - 1);
          const step = 1 / segments;
          const pointCount = fineCols * fineRows;

          const positions = new Float32Array(pointCount * 3);
          const colors = new Float32Array(pointCount * 3);
          const sampleIndices = new Int32Array(pointCount * 4);
          const sampleWeights = new Float32Array(pointCount * 4);

          const halfX = sensorW / 2;
          const halfZ = sensorH / 2;

          let ptr = 0;
          for (let fy = 0; fy < fineRows; fy += 1) {
            const sy = fineH === 0 ? 0 : (fy / fineH) * sensorH;
            const y0 = Math.floor(sy);
            const y1 = Math.min(safeRows - 1, y0 + 1);
            const ty = sy - y0;
            for (let fx = 0; fx < fineCols; fx += 1) {
                const sx = fineW === 0 ? 0 : (fx / fineW) * sensorW;
                const x0 = Math.floor(sx);
                const x1 = Math.min(safeCols - 1, x0 + 1);
                const tx = sx - x0;

                const p = (fy * fineCols + fx) * 3;
                positions[p] = fx * step - halfX;
                positions[p + 1] = 0;
                positions[p + 2] = fy * step - halfZ;

                const w00 = (1 - tx) * (1 - ty);
                const w10 = tx * (1 - ty);
                const w01 = (1 - tx) * ty;
                const w11 = tx * ty;

                sampleIndices[ptr] = y0 * safeCols + x0;
                sampleWeights[ptr] = w00; ptr++;
                sampleIndices[ptr] = y0 * safeCols + x1;
                sampleWeights[ptr] = w10; ptr++;
                sampleIndices[ptr] = y1 * safeCols + x0;
                sampleWeights[ptr] = w01; ptr++;
                sampleIndices[ptr] = y1 * safeCols + x1;
                sampleWeights[ptr] = w11; ptr++;

                const c = SURFACE_MISSING_RGB;
                const cBase = (fy * fineCols + fx) * 3;
                colors[cBase] = c[0]; colors[cBase+1] = c[1]; colors[cBase+2] = c[2];
            }
          }
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
          geometry.userData = { rows: safeRows, cols: safeCols, fineRows, fineCols, step };
          return { geometry, sampleIndices, sampleWeights };
      }

      function ensureThreeSurface(panel, rows, cols) {
        if (!panel || !panel.heatmapContainer || !threeIsAvailable()) return null;
        const safeRows = Math.max(1, rows);
        const safeCols = Math.max(1, cols);

        if (!panel.three) {
          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setPixelRatio(window.devicePixelRatio || 1);
          renderer.domElement.className = "pressure-surface-canvas";
          
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 1000);
          const controls = new window.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = false;
          controls.target.set(0, 0, 0);
          controls.update();

          const built = buildSurfaceGeometry(safeRows, safeCols, SURFACE_SUBDIV);
          const material = new THREE.PointsMaterial({
            size: Math.max(0.04, built.geometry.userData.step * 1.8),
            sizeAttenuation: true,
            vertexColors: true,
            transparent: true,
            opacity: 0.95
          });
          const points = new THREE.Points(built.geometry, material);
          scene.add(points);

          const span = Math.max(safeCols - 1, safeRows - 1, 1);
          camera.position.set(0, span * 0.9, span * 1.4);
          camera.lookAt(0, 0, 0);
          controls.minDistance = span * 0.6;
          controls.maxDistance = span * 8;
          controls.update();

          const three = {
            renderer, scene, camera, controls, points,
            geometry: built.geometry,
            sampleIndices: built.sampleIndices,
            sampleWeights: built.sampleWeights,
            rows: safeRows, cols: safeCols,
            needsResize: true, lastWidth: 0, lastHeight: 0
          };
          controls.addEventListener("change", () => {
             if (three.lastWidth > 0) renderer.render(scene, camera);
          });
          panel.three = three;
          return three;
        }

        const three = panel.three;
        if (three.rows !== safeRows || three.cols !== safeCols) {
           if (three.geometry) three.geometry.dispose();
           const built = buildSurfaceGeometry(safeRows, safeCols, SURFACE_SUBDIV);
           three.geometry = built.geometry;
           three.sampleIndices = built.sampleIndices;
           three.sampleWeights = built.sampleWeights;
           three.rows = safeRows;
           three.cols = safeCols;
           three.needsResize = true;
           three.points.geometry = three.geometry;
           
           const span = Math.max(safeCols - 1, safeRows - 1, 1);
           three.camera.position.set(0, span * 0.9, span * 1.4);
           three.camera.lookAt(0, 0, 0);
           three.controls.minDistance = span * 0.6;
           three.controls.maxDistance = span * 8;
           three.controls.update();
           
           const newSize = Math.max(0.04, three.geometry.userData.step * 1.8);
           three.points.material.size = newSize;
        }
        return three;
      }

      function resizeThreeSurface(panel) {
          if (!panel || !panel.heatmapContainer || !panel.three) return;
          const container = panel.heatmapContainer;
          const width = container.clientWidth;
          const height = container.clientHeight;
          if (!width || !height) return;
          if (width === panel.three.lastWidth && height === panel.three.lastHeight) return;
          
          panel.three.lastWidth = width;
          panel.three.lastHeight = height;
          panel.three.renderer.setSize(width, height, false);
          panel.three.camera.aspect = width / height;
          panel.three.camera.updateProjectionMatrix();
      }
      
      function updateThreeSurface(panel, ctx, range) {
          const three = panel?.three;
          if (!three || !ctx || ctx.state !== 'ready') return;
          const sensorValues = ctx.displayValues;
          
          const min = Number.isFinite(range?.min) ? range.min : 0;
          const max = Number.isFinite(range?.max) ? range.max : min;
          const rangeSpan = max - min;
          const span = Math.max(ctx.cols - 1, ctx.rows - 1, 1);
          const heightScale = rangeSpan > 0 ? (span * SURFACE_HEIGHT_FRACTION) / rangeSpan : 0;
          
          const posAttr = three.geometry.getAttribute("position");
          const colAttr = three.geometry.getAttribute("color");
          const pos = posAttr.array;
          const col = colAttr.array;
          const indices = three.sampleIndices;
          const weights = three.sampleWeights;
          const pointCount = indices.length / 4;
          const lut = SURFACE_GRADIENT_LUT;
          const missing = SURFACE_MISSING_RGB;
          const lutSize = SURFACE_LUT_SIZE;
          
          for (let i = 0; i < pointCount; i++) {
              const base4 = i * 4;
              let sum = 0, wSum = 0;
              for (let k = 0; k < 4; k++) {
                  const idx = indices[base4+k];
                  const w = weights[base4+k];
                  const v = sensorValues[idx];
                  if (Number.isFinite(v) && w > 0) {
                      sum += v * w;
                      wSum += w;
                  }
              }
              const value = wSum > 0 ? sum/wSum : NaN;
              const posBase = i * 3;
              const colBase = i * 3;
              
              if (!Number.isFinite(value)) {
                  pos[posBase + 1] = 0;
                  col[colBase] = missing[0]; col[colBase+1] = missing[1]; col[colBase+2] = missing[2];
                  continue;
              }
              
              const clamped = Math.min(max, Math.max(min, value));
              pos[posBase + 1] = heightScale > 0 ? (clamped - min) * heightScale : 0;
              const ratio = rangeSpan > 0 ? (clamped - min) / rangeSpan : 0;
              const lutIdx = Math.max(0, Math.min(lutSize - 1, Math.round(ratio * (lutSize - 1))));
              const lutBase = lutIdx * 3;
              col[colBase] = lut[lutBase]; col[colBase+1] = lut[lutBase+1]; col[colBase+2] = lut[lutBase+2];
          }
          posAttr.needsUpdate = true;
          colAttr.needsUpdate = true;
      }
      
      // --- Render Orchestration ---
      
      window.addEventListener("three-ready", () => {
          updateAllHeatmaps();
          requestSurfaceRefresh();
      });
      if (window.__three_ready) {
          updateAllHeatmaps();
          requestSurfaceRefresh();
      }

      function arraysEqual(left, right) {
        if (left.length !== right.length) return false;
        for (let i = 0; i < left.length; i++) {
          if (left[i] !== right[i]) return false;
        }
        return true;
      }

      function applyMirroring(values, rows, cols, options = {}) {
        const mirrorRowsFlag = Boolean(options.mirrorRows);
        const mirrorColsFlag = Boolean(options.mirrorCols);
        if (!rows || !cols) return values.slice();
        const result = [];
        for (let displayRow = 0; displayRow < rows; displayRow += 1) {
          const sourceRow = mirrorRowsFlag ? rows - 1 - displayRow : displayRow;
          const start = sourceRow * cols;
          const rowValues = values.slice(start, start + cols);
          if (mirrorColsFlag) rowValues.reverse();
          result.push(...rowValues);
        }
        return result;
      }
      
      function persistMirrorSettings(panel) {
          if (!panel || !panel.selectedDevice) return;
          mirrorSettingsByDevice.set(panel.selectedDevice, {
              rows: panel.mirrorRows,
              cols: panel.mirrorCols
          });
      }
      
      function syncPanelMirrorControls(panel) {
          if (!panel) return;
          const settings = panel.selectedDevice ? mirrorSettingsByDevice.get(panel.selectedDevice) : null;
          panel.mirrorRows = settings ? Boolean(settings.rows) : false;
          panel.mirrorCols = settings ? Boolean(settings.cols) : false;
          panel.mirrorRowsToggle.checked = panel.mirrorRows;
          panel.mirrorColsToggle.checked = panel.mirrorCols;
          
          const disabled = !panel.selectedDevice;
          panel.mirrorRowsToggle.disabled = disabled;
          panel.mirrorColsToggle.disabled = disabled;
      }

      function updatePanelRecordingState(panel) {
          if (!panel || !panel.recordBtn) return;
          const disabled = !panel.selectedDevice;
          panel.recordBtn.disabled = disabled;
          
          if (disabled) {
              panel.recordBtn.classList.remove("btn-danger", "pulsing-record");
              panel.recordBtn.classList.add("btn-outline-danger");
              return;
          }
          
          const isRecording = recordingStateByDevice.get(panel.selectedDevice) || false;
          if (isRecording) {
              panel.recordBtn.classList.remove("btn-outline-danger");
              panel.recordBtn.classList.add("btn-danger", "pulsing-record");
          } else {
              panel.recordBtn.classList.remove("btn-danger", "pulsing-record");
              panel.recordBtn.classList.add("btn-outline-danger");
          }
      }
      
      function setPanelPlaceholder(panel, key) {
          if (!panel || !panel.heatmapContainer) return;
          panel.heatmapContainer.classList.remove("has-3d");
          panel.heatmapContainer.innerHTML = `<div class="heatmap-placeholder">${t(key)}</div>`;
      }
      
      function lerp(start, end, t) {
          if (!Number.isFinite(start) || !Number.isFinite(end)) return end;
          return start + (end - start) * Math.max(0, Math.min(1, t));
      }

      function lerpArray(startArr, endArr, t) {
          if (!startArr || !endArr || startArr.length !== endArr.length) return endArr;
          return startArr.map((v, i) => lerp(v, endArr[i], t));
      }

      function getInterpolatedState(dn) {
          const entry = state.get(dn);
          if (!entry || !entry.lastState) return entry;

          const now = Date.now();
          // Assume 50Hz (20ms) data rate, interpolate over this window
          // Or use the actual time difference between frames if available/reliable
          // Using a fixed small window for smoothing feels better for "gap filling"
          
          // However, for "missing data" we want to smooth over the gap. 
          // If we receive data at T1 and T2, we want to animate from V1 to V2.
          // But we only receive V2 at T2. So we are always "lagging" by the interpolation window.
          // For real-time monitoring without artificial delay, we can only interpolate 
          // if we intentionally buffer.
          // BUT, user asked to "fill frames". 
          // A common simple trick: 
          // When V2 arrives, don't jump to it. Animate towards it.
          // This requires a separate "renderState" that chases "targetState".
          
          return entry; // Placeholder for now, switching strategy below
      }
      
      // Strategy Switch: "Chasing" Value Interpolation
      // We maintain a separate 'displayState' for each device that chases the latest 'networkState' (state.get(dn))
      const displayStates = new Map();
      const LERP_FACTOR = 0.15; // Lower factor for smoother 60FPS animation with high-rate data

      function getDisplayState(dn) {
          const target = state.get(dn);
          if (!target) return null;
          
          let current = displayStates.get(dn);
          if (!current) {
              // First frame, jump directly
              current = { ...target };
              displayStates.set(dn, current);
              return current;
          }
          
          // LERP pressure values
          current.pressureValues = lerpArray(current.pressureValues, target.pressureValues, LERP_FACTOR);
          
          // LERP IMU if needed (optional, might be too jittery if LERP'd)
          if (target.gyro) current.gyro = lerpArray(current.gyro || [0,0,0], target.gyro, LERP_FACTOR);
          if (target.acc) current.acc = lerpArray(current.acc || [0,0,0], target.acc, LERP_FACTOR);
          
          return current;
      }
      
      function buildPanelRenderContext(panel) {
          if (!panel.selectedDevice) return { state: "no_device" };
          const entry = getDisplayState(panel.selectedDevice); // Use interpolated state
          if (!entry) return { state: "waiting" };
          const layout = parseLayoutKey(panel.selectedLayoutKey);
          if (!layout) return { state: "no_layout" };
          const [rows, cols] = layout;
          const totalCells = rows * cols;
          const values = Array.isArray(entry.pressureValues) ? entry.pressureValues.slice(0, totalCells) : [];
          while (values.length < totalCells) values.push(NaN);
          const displayValues = applyMirroring(values, rows, cols, {
              mirrorRows: panel.mirrorRows,
              mirrorCols: panel.mirrorCols
          });
          const validValues = values.filter(v => Number.isFinite(v));
          const hasValidValues = validValues.length > 0;
          const dataMin = hasValidValues ? Math.min(...validValues) : null;
          const dataMax = hasValidValues ? Math.max(...validValues) : null;
          return { state: "ready", rows, cols, displayValues, dataMin, dataMax };
      }
      
      function renderPanelHeatmap(panel, ctx, range) {
          const container = panel.heatmapContainer;
          container.classList.remove("has-3d");
          if (!ctx || ctx.state === "no_device") {
              setPanelPlaceholder(panel, "heatmap.empty.no_device");
              return;
          }
          if (ctx.state === "waiting") {
              setPanelPlaceholder(panel, "heatmap.empty.waiting");
              return;
          }
          if (ctx.state === "no_layout") {
              setPanelPlaceholder(panel, "heatmap.empty.no_layout");
              return;
          }
          if (ctx.state !== "ready") return;
          
          if (!threeIsAvailable()) {
              container.innerHTML = '<div class="heatmap-placeholder">3D Library Not Loaded</div>';
              return;
          }
          
          const three = ensureThreeSurface(panel, ctx.rows, ctx.cols);
          if (!three) {
              container.innerHTML = '<div class="heatmap-placeholder">3D Init Failed</div>';
              return;
          }
          if (three.renderer.domElement.parentElement !== container) {
              container.innerHTML = "";
              container.appendChild(three.renderer.domElement);
              three.needsResize = true;
          }
          container.classList.add("has-3d");
          resizeThreeSurface(panel);
          three.needsResize = false;
          updateThreeSurface(panel, ctx, range);
          three.controls.update();
          three.renderer.render(three.scene, three.camera);
      }
      
      function updateAllHeatmaps() {
          const panelData = panels.map(panel => ({ panel, ctx: buildPanelRenderContext(panel) }));
          const mins = panelData.filter(d => d.ctx.state === "ready" && Number.isFinite(d.ctx.dataMin)).map(d => d.ctx.dataMin);
          const maxs = panelData.filter(d => d.ctx.state === "ready" && Number.isFinite(d.ctx.dataMax)).map(d => d.ctx.dataMax);
          const dataMin = mins.length ? Math.min(...mins) : null;
          const dataMax = maxs.length ? Math.max(...maxs) : null;
          
          updateRangePlaceholders(dataMin, dataMax);
          const range = resolveEffectiveRange(dataMin, dataMax);
          
          panelData.forEach(({ panel, ctx }) => {
              panelRenderCache.set(panel.key, ctx);
              renderPanelHeatmap(panel, ctx, range);
          });
          panels.forEach(updatePanelCop);
      }

      function updateLayoutOptionsForPanel(panel) {
          const entry = panel.selectedDevice ? state.get(panel.selectedDevice) : null;
          if (!entry) {
              panel.layoutSelector.innerHTML = "";
              panel.layoutSelector.disabled = true;
              panel.selectedLayoutKey = null;
              panel.layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: currentLanguage };
              setPanelPlaceholder(panel, panel.selectedDevice ? "heatmap.empty.waiting" : "heatmap.empty.no_device");
              updatePanelSensors(panel);
              updatePanelCop(panel);
              return;
          }
          const sensorCount = Number.isInteger(entry.sensorCount) ? entry.sensorCount : (entry.pressureValues?.length || 0);
          const pairs = computeFactorPairs(sensorCount);
          if (!pairs.length) {
              panel.layoutSelector.innerHTML = "";
              panel.layoutSelector.disabled = true;
              panel.selectedLayoutKey = null;
              panel.layoutOptionsCache = { dn: entry.dn, sensorCount, options: [], selectedKey: null, lang: currentLanguage };
              setPanelPlaceholder(panel, "heatmap.empty.no_layout");
              updatePanelSensors(panel);
              updatePanelCop(panel);
              return;
          }
          const optionKeys = pairs.map(([r, c]) => `${r}x${c}`);
          const optionsChanged = panel.layoutOptionsCache.dn !== entry.dn ||
                                 !arraysEqual(optionKeys, panel.layoutOptionsCache.options) ||
                                 panel.layoutOptionsCache.lang !== currentLanguage;
                                 
          if (optionsChanged) {
              panel.layoutSelector.innerHTML = "";
              pairs.forEach(([r, c]) => {
                  const key = `${r}x${c}`;
                  const option = document.createElement("option");
                  option.value = key;
                  option.textContent = `${r} × ${c}`;
                  panel.layoutSelector.appendChild(option);
              });
          }
          
          if (!panel.selectedLayoutKey || !optionKeys.includes(panel.selectedLayoutKey)) {
              if (panel.layoutOptionsCache.selectedKey && optionKeys.includes(panel.layoutOptionsCache.selectedKey)) {
                  panel.selectedLayoutKey = panel.layoutOptionsCache.selectedKey;
              } else {
                  panel.selectedLayoutKey = chooseDefaultLayout(pairs);
              }
          }
          panel.layoutSelector.value = panel.selectedLayoutKey || "";
          panel.layoutSelector.disabled = false;
          panel.layoutOptionsCache = { dn: entry.dn, sensorCount, options: optionKeys, selectedKey: panel.selectedLayoutKey, lang: currentLanguage };
          
          updatePanelSensors(panel);
          updatePanelCop(panel);
      }
      
      function updateDeviceOptions() {
          const devices = Array.from(state.keys()).sort();
          let changed = false;
          panels.forEach(panel => {
              const previousSelection = panel.selectedDevice;
              const listChanged = !arraysEqual(devices, panel.deviceOptionsCache.devices);
              const langChanged = panel.deviceOptionsCache.lang !== currentLanguage;
              
              if (listChanged || langChanged) {
                  panel.deviceSelector.innerHTML = "";
                  if (!devices.length) {
                      const opt = document.createElement("option");
                      opt.value = "";
                      opt.textContent = t("controls.waiting");
                      panel.deviceSelector.appendChild(opt);
                  } else {
                      devices.forEach(dn => {
                          const opt = document.createElement("option");
                          opt.value = dn;
                          opt.textContent = dn;
                          panel.deviceSelector.appendChild(opt);
                      });
                  }
              }
              
              if (!panel.selectedDevice || !devices.includes(panel.selectedDevice)) {
                  // If we lost the device, pick a default?
                  // Try to pick one that isn't selected by others?
                  const used = panels.map(p => p.selectedDevice).filter(d => d);
                  const available = devices.filter(d => !used.includes(d));
                  if (available.length > 0) {
                      panel.selectedDevice = available[0];
                  } else if (devices.length > 0 && !devices.includes(panel.selectedDevice)) {
                      panel.selectedDevice = devices[0];
                  } else if (devices.length === 0) {
                      panel.selectedDevice = null;
                  }
              }
              
              panel.deviceSelector.value = panel.selectedDevice || "";
              panel.deviceSelector.disabled = devices.length === 0;
              
              if (panel.selectedDevice !== previousSelection) {
                  changed = true;
                  syncPanelMirrorControls(panel);
              }
              panel.deviceOptionsCache = { devices, selected: panel.selectedDevice, lang: currentLanguage };
              updatePanelSensors(panel);
              updatePanelCop(panel);
              updatePanelRecordingState(panel);
          });
          return changed;
      }
      
      function formatAxisReading(value, options = {}) {
        const scale = options.scale || 1;
        if (!Number.isFinite(value)) return "--";
        const scaled = value * scale;
        const abs = Math.abs(scaled);
        const decimals = abs < 10 ? 2 : (abs < 100 ? 1 : 0);
        return scaled.toFixed(decimals);
      }
      
      function updatePanelSensors(panel) {
        if (!panel.selectedDevice) {
            ["x","y","z"].forEach(k => {
                if (panel.gyroElements[k]) panel.gyroElements[k].textContent = "--";
                if (panel.accElements[k]) panel.accElements[k].textContent = "--";
            });
            return;
        }
        const entry = getDisplayState(panel.selectedDevice); // Use interpolated state
        const gyro = entry?.gyro;
        ["x", "y", "z"].forEach((axis, idx) => {
             const v = gyro && Number.isFinite(gyro[idx]) ? gyro[idx] : null;
             panel.gyroElements[axis].textContent = v !== null ? formatAxisReading(v) : "--";
        });
        const acc = entry?.acc;
         ["x", "y", "z"].forEach((axis, idx) => {
             const v = acc && Number.isFinite(acc[idx]) ? acc[idx] : null;
             panel.accElements[axis].textContent = v !== null ? formatAxisReading(v, {scale: 9.8}) : "--";
        });
      }
      
      function updatePanelCop(panel) {
          if (!panel.copBoard) return;
          if (!copVisible) {
             // Already handled by CSS class toggle, but good to bail
             return; 
          }
          const ctx = panelRenderCache.get(panel.key);
          const board = panel.copBoard;
          const dot = panel.copDot;
          
          if (!ctx || ctx.state !== "ready" || !Array.isArray(ctx.displayValues)) {
             board.classList.remove("has-data");
             if (dot) { dot.style.left = "50%"; dot.style.top = "50%"; }
             if (panel.copXValue) panel.copXValue.textContent = "--";
             if (panel.copYValue) panel.copYValue.textContent = "--";
             if (panel.copPlaceholder) panel.copPlaceholder.textContent = t("overview.cop_empty");
             return;
          }
          
          const { rows, cols, displayValues } = ctx;
          let total = 0, sumX = 0, sumY = 0;
          const OFFSET = 250;
          displayValues.forEach((v, i) => {
              if (Number.isFinite(v)) {
                  const adj = v - OFFSET;
                  if (adj <= 0) return;
                  const r = Math.floor(i / cols);
                  const c = i % cols;
                  total += adj;
                  sumX += adj * c;
                  sumY += adj * r;
              }
          });
          
          if (total <= 0) {
             board.classList.remove("has-data");
             if (panel.copXValue) panel.copXValue.textContent = "--";
             if (panel.copYValue) panel.copYValue.textContent = "--";
             if (panel.copPlaceholder) panel.copPlaceholder.textContent = t("overview.cop_empty");
             return;
          }
          
          const copX = sumX / total;
          const copY = sumY / total;
          if (panel.copXValue) panel.copXValue.textContent = copX.toFixed(2);
          if (panel.copYValue) panel.copYValue.textContent = copY.toFixed(2);
          
          const colMax = Math.max(cols - 1, 1);
          const rowMax = Math.max(rows - 1, 1);
          const centerX = (cols - 1) / 2;
          const centerY = (rows - 1) / 2;
          const halfX = colMax / 2;
          const halfY = rowMax / 2;
          
          let xRatio = (copX - (centerX - halfX)) / colMax;
          let yRatio = (copY - (centerY - halfY)) / rowMax;
          xRatio = Math.min(1, Math.max(0, xRatio));
          yRatio = Math.min(1, Math.max(0, yRatio));
          
          board.classList.add("has-data");
          if (dot) {
              dot.style.left = `${xRatio * 100}%`;
              dot.style.top = `${yRatio * 100}%`;
          }
      }

      function updateSummary() {
        const now = Date.now();
        let active = 0;
        for (const entry of state.values()) {
          if (entry.receivedAt && now - entry.receivedAt <= STALE_THRESHOLD_MS) active++;
        }
        if (activeDevicesLabel) activeDevicesLabel.textContent = active;
      }
      
      function updateTable() {
        const tbody = document.querySelector("#device-table tbody");
        const now = Date.now();
        const rows = Array.from(state.values()).sort((a, b) => (a.dn || "").localeCompare(b.dn || ""));
        tbody.innerHTML = "";
        const stopLabel = t("table.actions.stop_tracking");
        for (const entry of rows) {
            const tr = document.createElement("tr");
            const isStale = !entry.receivedAt || now - entry.receivedAt > STALE_THRESHOLD_MS;
            if (isStale) tr.classList.add("text-muted");
            tr.innerHTML = `
              <td><code>${entry.dn}</code></td>
              <td>${entry.sensorCount ?? "--"}</td>
              <td>${entry.frameTime ? new Date(entry.frameTime).toLocaleString() : "--"}</td>
              <td>${entry.receivedAt ? new Date(entry.receivedAt).toLocaleString() : "--"}</td>
              <td class="text-center">
                <button type="button" class="btn btn-sm btn-outline-danger remove-device" data-dn="${entry.dn}">${stopLabel}</button>
              </td>
            `;
            tr.querySelector(".remove-device").addEventListener("click", (e) => {
                e.stopPropagation();
                removeDevice(entry.dn);
            });
            tbody.appendChild(tr);
        }
      }
      
      function removeDevice(dn) {
          if (!state.has(dn)) return;
          state.delete(dn);
          mirrorSettingsByDevice.delete(dn);
          recordingStateByDevice.delete(dn);
          panels.forEach(p => {
              if (p.selectedDevice === dn) {
                  p.selectedDevice = null;
                  p.selectedLayoutKey = null;
                  updateLayoutOptionsForPanel(p);
                  updatePanelRecordingState(p);
              }
          });
          refreshUI();
      }

      function performRefresh() {
          pendingRefresh = false;
          lastRefreshTimestamp = Date.now();
          updateSummary();
          updateTable();
          const devChanged = updateDeviceOptions();
          panels.forEach(p => {
              if (devChanged || p.selectedDevice) updateLayoutOptionsForPanel(p);
          });
          updateAllHeatmaps();
          if (lastUpdateLabel) {
             const latest = Array.from(state.values()).reduce((m, e) => Math.max(m, e.receivedAt || 0), 0);
             lastUpdateLabel.textContent = latest ? new Date(latest).toLocaleString() : "--";
          }
      }
      
      function refreshUI() {
          pendingRefresh = true;
          if (refreshTimerId !== null) return;
          const now = Date.now();
          const elapsed = now - lastRefreshTimestamp;
          const delay = Math.max(REFRESH_INTERVAL_MS - elapsed, 0);
          refreshTimerId = window.setTimeout(() => {
              refreshTimerId = null;
              if (pendingRefresh) performRefresh();
          }, delay);
      }
      
      function requestSurfaceRefresh() {
          surfaceDirty = true;
          surfaceLoopActiveUntil = Math.max(surfaceLoopActiveUntil, performance.now() + SURFACE_LOOP_IDLE_MS);
          if (surfaceLoopRafId === null) surfaceLoopRafId = window.requestAnimationFrame(surfaceLoopTick);
      }
      
      function surfaceLoopTick(ts) {
          // If active window expired, stop loop
          if (ts > surfaceLoopActiveUntil) {
              surfaceLoopRafId = null;
              return;
          }
          surfaceLoopRafId = window.requestAnimationFrame(surfaceLoopTick);
          
          if (document.hidden) return;
          // Note: We ignore 'surfaceDirty' here to ensure continuous interpolation (LERP) 
          // runs every frame while the loop is active (data recently arrived).
          surfaceDirty = false;
          
          const panelData = panels.map(panel => ({ panel, ctx: buildPanelRenderContext(panel) }));
          const mins = panelData.filter(d => d.ctx.state === "ready" && Number.isFinite(d.ctx.dataMin)).map(d => d.ctx.dataMin);
          const maxs = panelData.filter(d => d.ctx.state === "ready" && Number.isFinite(d.ctx.dataMax)).map(d => d.ctx.dataMax);
          const dataMin = mins.length ? Math.min(...mins) : null;
          const dataMax = maxs.length ? Math.max(...maxs) : null;
          const range = resolveEffectiveRange(dataMin, dataMax);
          
          panelData.forEach(({ panel, ctx }) => {
              panelRenderCache.set(panel.key, ctx);
              renderPanelHeatmap(panel, ctx, range);
              updatePanelSensors(panel);
              updatePanelCop(panel);
          });
      }

      function shouldRequestSurfaceRefreshForDn(dn) {
          return panels.some(p => p.selectedDevice === dn && p.selectedLayoutKey);
      }

      // --- Data Ingestion ---
      function normalizeEntry(entry) {
        if (!entry || typeof entry !== "object") return null;
        const dn = entry.dn || "UNKNOWN";
        const payload = entry.payload || {};
        let sensorCount = null;
        let frameTime = null;
        let pressureValues = [];
        let gyroValues = null;
        let accValues = null;
        
        if (payload && typeof payload === "object") {
             const rawP = Array.isArray(payload.p) ? payload.p : [];
             const numP = rawP.map(v => { const n = Number(v); return Number.isFinite(n) ? n : NaN; });
             sensorCount = Number(payload.sn);
             if (!Number.isInteger(sensorCount) || sensorCount <= 0) sensorCount = numP.length;
             pressureValues = numP.slice(0, sensorCount);
             while (pressureValues.length < sensorCount) pressureValues.push(NaN);
             if (payload.ts) frameTime = payload.ts * 1000;
             
             if (Array.isArray(payload.gyro)) {
                 const g = payload.gyro.map(Number);
                 gyroValues = [g[0], g[1], g[2]];
             }
             if (Array.isArray(payload.acc)) {
                 const a = payload.acc.map(Number);
                 accValues = [a[0], a[1], a[2]];
             }
        }
        
        // Prevent out-of-order updates
        if (state.has(dn)) {
             const existing = state.get(dn);
             if (frameTime && existing.frameTime && frameTime < existing.frameTime) return null;
        }

        return {
            dn, sensorCount, frameTime,
            receivedAt: entry.received_at ? Date.parse(entry.received_at) : Date.now(),
            pressureValues, gyro: gyroValues, acc: accValues, raw: entry
        };
      }
      
      function applyEntry(entry, options = {}) {
          const normalized = normalizeEntry(entry);
          if (!normalized) return;
          
          const existing = state.get(normalized.dn);
          if (existing) {
              // Store previous state for interpolation
              normalized.lastState = {
                  pressureValues: existing.pressureValues,
                  gyro: existing.gyro,
                  acc: existing.acc,
                  frameTime: existing.frameTime,
                  receivedAt: existing.receivedAt
              };
          }
          
          state.set(normalized.dn, normalized);
          if (!options.defer && shouldRequestSurfaceRefreshForDn(normalized.dn)) {
              requestSurfaceRefresh();
          }
          if (!options.defer) refreshUI();
      }
      
      async function fetchSnapshot() {
          try {
              const resp = await fetch(SNAPSHOT_ENDPOINT);
              const data = await resp.json();
              if (Array.isArray(data.data)) {
                  data.data.forEach(item => applyEntry(item, { defer: true }));
                  refreshUI();
              }
              setStatusIndicator("snapshot_ok");
              statusIndicator.className = "badge bg-success d-block";
          } catch (err) {
              setStatusIndicator("snapshot_error");
              statusIndicator.className = "badge bg-danger d-block";
              console.error(t("console.snapshot_fetch_failed"), err);
          }
      }
      
      function cleanupEventSource() {
          if (currentEventSource) {
              currentEventSource.close();
              currentEventSource = null;
          }
      }
      function clearStreamReconnectTimer() {
        if (streamReconnectTimerId !== null) {
          window.clearTimeout(streamReconnectTimerId);
          streamReconnectTimerId = null;
        }
      }
      function scheduleStreamReconnect() {
        if (streamReconnectTimerId !== null) return;
        const delay = Math.min(
          STREAM_RECONNECT_BASE_DELAY_MS * Math.max(1, Math.pow(2, streamReconnectAttempts)),
          STREAM_RECONNECT_MAX_DELAY_MS
        );
        streamReconnectTimerId = window.setTimeout(() => {
          streamReconnectTimerId = null;
          streamReconnectAttempts++;
          subscribeStream();
        }, delay);
      }

      function subscribeStream() {
          cleanupEventSource();
          clearStreamReconnectTimer();
          const source = new EventSource(STREAM_ENDPOINT);
          currentEventSource = source;
          setStatusIndicator("connecting");
          statusIndicator.className = "badge bg-secondary d-block";
          
          source.addEventListener("snapshot", (e) => {
              try {
                  const payload = JSON.parse(e.data);
                  if (Array.isArray(payload.data)) {
                      payload.data.forEach(item => applyEntry(item, {defer: true}));
                      refreshUI();
                  }
              } catch(err) { console.error(err); }
          });
          source.addEventListener("update", (e) => {
              try {
                  applyEntry(JSON.parse(e.data));
              } catch(err) { console.error(err); }
          });
          source.addEventListener("error", () => {
              setStatusIndicator("stream_error");
              statusIndicator.className = "badge bg-warning d-block";
              cleanupEventSource();
              const shouldFetch = streamReconnectTimerId === null;
              scheduleStreamReconnect();
              if (shouldFetch) fetchSnapshot();
          });
          source.onopen = () => {
              clearStreamReconnectTimer();
              streamReconnectAttempts = 0;
              setStatusIndicator("stream_ok");
              statusIndicator.className = "badge bg-success d-block";
          };
      }
      
      // Init
      fetchSnapshot();
      if (snapshotPollTimerId === null) snapshotPollTimerId = window.setInterval(fetchSnapshot, SNAPSHOT_POLL_INTERVAL_MS);
      let resizeRafId = null;
      window.addEventListener("resize", () => {
          if (resizeRafId !== null) return;
          resizeRafId = window.requestAnimationFrame(() => {
              resizeRafId = null;
              panels.forEach(panel => {
                  if (panel.three && panel.heatmapContainer.classList.contains("has-3d")) {
                      resizeThreeSurface(panel);
                      panel.three.renderer.render(panel.three.scene, panel.three.camera);
                  }
              });
          });
      });
      window.addEventListener("beforeunload", () => {
          cleanupEventSource();
          clearStreamReconnectTimer();
          if (snapshotPollTimerId !== null) window.clearInterval(snapshotPollTimerId);
      });
      subscribeStream();

    </script>
  </body>
</html>