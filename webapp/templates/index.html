<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>实时压力监控面板</title>

    <!-- 去掉 integrity / crossorigin -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    />

    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body>
    <div class="container py-4">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
          <h1 class="h3 mb-1">实时压力监控面板</h1>
          <p class="text-muted mb-0">
            数据来源：<code>{{ bridge_api_base }}</code>
          </p>
        </div>
        <div class="text-end">
          <div class="badge bg-secondary" id="status-indicator">连接中...</div>
          <div class="small text-muted" id="last-update">--</div>
        </div>
      </div>
  
      <div class="row g-4">
        <div class="col-lg-8">
          <div class="card shadow-sm h-100">
            <div class="card-body">
              <div class="d-flex flex-column flex-xl-row align-items-xl-center justify-content-between gap-3 mb-3">
                <h2 class="h5 mb-0">压力热力图</h2>
                <div class="w-100">
                  <div class="row gy-2 gx-2 align-items-stretch heatmap-controls">
                    <div class="col-12 col-md-6 col-xl-auto">
                      <div class="input-group">
                        <span class="input-group-text">设备</span>
                        <select class="form-select" id="device-selector" disabled>
                          <option value="">等待数据...</option>
                        </select>
                      </div>
                    </div>
                    <div class="col-12 col-md-6 col-xl-auto">
                      <div class="input-group">
                        <span class="input-group-text">行 × 列</span>
                        <select class="form-select" id="layout-selector" disabled>
                          <option value="">--</option>
                        </select>
                      </div>
                    </div>
                    <div class="col-12 col-xl">
                      <div class="input-group pressure-range-group">
                        <span class="input-group-text">压力范围</span>
                        <input
                          type="number"
                          class="form-control"
                          id="pressure-min"
                          placeholder="下限"
                          step="any"
                        />
                        <span class="input-group-text">~</span>
                        <input
                          type="number"
                          class="form-control"
                          id="pressure-max"
                          placeholder="上限"
                          step="any"
                        />
                        <button class="btn btn-outline-secondary" type="button" id="reset-range">
                          重置
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div id="heatmap-container">
                <div class="heatmap-placeholder">等待数据...</div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-4">
          <div class="card shadow-sm h-100">
            <div class="card-body">
              <h2 class="h5 mb-3">当前概览</h2>
              <div class="mb-3">
                <div class="fw-semibold">活跃设备</div>
                <div class="display-6" id="active-devices">0</div>
              </div>
              <div>
                <div class="fw-semibold">总压力</div>
                <div class="display-6" id="total-pressure">0</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card shadow-sm mt-4">
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <h2 class="h5 mb-0">设备详情</h2>
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="autoScroll" checked />
              <label class="form-check-label" for="autoScroll">新数据时自动滚动</label>
            </div>
          </div>
          <div class="table-responsive" style="max-height: 360px;">
            <table class="table table-striped align-middle" id="device-table">
              <thead class="table-light sticky-top">
                <tr>
                  <th scope="col">DN</th>
                  <th scope="col">压力传感器数</th>
                  <th scope="col">压力总和</th>
                  <th scope="col">最新帧时间</th>
                  <th scope="col">接收时间</th>
                  <th scope="col" class="text-center">操作</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <script>
      const SNAPSHOT_ENDPOINT = "{{ url_for('proxy_latest') }}";
      const STREAM_ENDPOINT = "{{ url_for('proxy_stream') }}";

      const state = new Map();
      const STALE_THRESHOLD_MS = 30 * 1000;
      const deviceSelector = document.getElementById("device-selector");
      const layoutSelector = document.getElementById("layout-selector");
      const heatmapContainer = document.getElementById("heatmap-container");
      const pressureMinInput = document.getElementById("pressure-min");
      const pressureMaxInput = document.getElementById("pressure-max");
      const resetRangeButton = document.getElementById("reset-range");
      let selectedDevice = null;
      let selectedLayoutKey = null;
      let customRangeMin = null;
      let customRangeMax = null;

      const COLOR_GREEN = [46, 204, 113];
      const COLOR_YELLOW = [241, 196, 15];
      const COLOR_ORANGE = [243, 156, 18];
      const COLOR_RED = [231, 76, 60];

      const GRADIENT_STOPS = [
        { stop: 0, color: COLOR_GREEN },
        { stop: 0.33, color: COLOR_YELLOW },
        { stop: 0.66, color: COLOR_ORANGE },
        { stop: 1, color: COLOR_RED }
      ];

      deviceSelector.addEventListener("change", (event) => {
        selectedDevice = event.target.value || null;
        updateLayoutOptions();
      });

      layoutSelector.addEventListener("change", (event) => {
        selectedLayoutKey = event.target.value || null;
        updateHeatmap();
      });

      if (pressureMinInput && pressureMaxInput) {
        ["input", "change"].forEach((eventName) => {
          pressureMinInput.addEventListener(eventName, handleCustomRangeChange);
          pressureMaxInput.addEventListener(eventName, handleCustomRangeChange);
        });
      }

      if (resetRangeButton) {
        resetRangeButton.addEventListener("click", () => {
          if (pressureMinInput) {
            pressureMinInput.value = "";
            pressureMinInput.classList.remove("is-invalid");
          }
          if (pressureMaxInput) {
            pressureMaxInput.value = "";
            pressureMaxInput.classList.remove("is-invalid");
          }
          customRangeMin = null;
          customRangeMax = null;
          updateHeatmap();
        });
      }

      function computeFactorPairs(sn) {
        if (!Number.isInteger(sn) || sn <= 0) {
          return [];
        }
        const basePairs = [];
        const limit = Math.floor(Math.sqrt(sn));
        for (let i = 1; i <= limit; i += 1) {
          if (sn % i === 0) {
            basePairs.push([i, sn / i]);
          }
        }
        const pairs = [];
        basePairs.forEach(([rows, cols]) => {
          pairs.push([rows, cols]);
          if (rows !== cols) {
            pairs.push([cols, rows]);
          }
        });
        pairs.sort((a, b) => {
          const diffA = Math.abs(a[0] - a[1]);
          const diffB = Math.abs(b[0] - b[1]);
          if (diffA !== diffB) return diffA - diffB;
          if (a[0] !== b[0]) return a[0] - b[0];
          return a[1] - b[1];
        });
        return pairs;
      }

      function chooseDefaultLayout(pairs) {
        if (!pairs.length) {
          return null;
        }
        return `${pairs[0][0]}x${pairs[0][1]}`;
      }

      function parseLayoutKey(key) {
        if (!key) {
          return null;
        }
        const [rows, cols] = key.split("x").map((value) => Number(value));
        if (!Number.isInteger(rows) || !Number.isInteger(cols)) {
          return null;
        }
        return [rows, cols];
      }

      function handleCustomRangeChange() {
        if (!pressureMinInput || !pressureMaxInput) {
          return;
        }
        const rawMin = pressureMinInput.value.trim();
        const rawMax = pressureMaxInput.value.trim();
        const hasMin = rawMin !== "";
        const hasMax = rawMax !== "";
        const minValue = Number(rawMin);
        const maxValue = Number(rawMax);
        const minValid = !hasMin || Number.isFinite(minValue);
        const maxValid = !hasMax || Number.isFinite(maxValue);

        pressureMinInput.classList.remove("is-invalid");
        pressureMaxInput.classList.remove("is-invalid");

        if (!minValid || !maxValid) {
          if (!minValid) {
            pressureMinInput.classList.add("is-invalid");
          }
          if (!maxValid) {
            pressureMaxInput.classList.add("is-invalid");
          }
          customRangeMin = null;
          customRangeMax = null;
          updateHeatmap();
          return;
        }

        if (hasMin && hasMax) {
          if (minValue < maxValue) {
            customRangeMin = minValue;
            customRangeMax = maxValue;
          } else {
            pressureMinInput.classList.add("is-invalid");
            pressureMaxInput.classList.add("is-invalid");
            customRangeMin = null;
            customRangeMax = null;
            updateHeatmap();
            return;
          }
        } else {
          customRangeMin = null;
          customRangeMax = null;
        }

        updateHeatmap();
      }

      function updateRangePlaceholders(dataMin, dataMax) {
        if (pressureMinInput) {
          if (Number.isFinite(dataMin)) {
            pressureMinInput.placeholder = dataMin.toFixed(2);
          } else {
            pressureMinInput.placeholder = "下限";
          }
        }
        if (pressureMaxInput) {
          if (Number.isFinite(dataMax)) {
            pressureMaxInput.placeholder = dataMax.toFixed(2);
          } else {
            pressureMaxInput.placeholder = "上限";
          }
        }
      }

      function resolveEffectiveRange(dataMin, dataMax) {
        if (
          Number.isFinite(customRangeMin) &&
          Number.isFinite(customRangeMax) &&
          customRangeMin < customRangeMax
        ) {
          return { min: customRangeMin, max: customRangeMax };
        }
        if (Number.isFinite(dataMin) && Number.isFinite(dataMax)) {
          return { min: dataMin, max: dataMax };
        }
        return { min: 0, max: 0 };
      }

      function toRgbString(color) {
        return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
      }

      function interpolateGradient(stops, ratio) {
        const clamped = Math.min(1, Math.max(0, ratio));
        for (let i = 1; i < stops.length; i += 1) {
          if (clamped <= stops[i].stop) {
            const prev = stops[i - 1];
            const next = stops[i];
            const span = next.stop - prev.stop || 1;
            const localT = span === 0 ? 0 : (clamped - prev.stop) / span;
            const r = Math.round(prev.color[0] + (next.color[0] - prev.color[0]) * localT);
            const g = Math.round(prev.color[1] + (next.color[1] - prev.color[1]) * localT);
            const b = Math.round(prev.color[2] + (next.color[2] - prev.color[2]) * localT);
            return `rgb(${r}, ${g}, ${b})`;
          }
        }
        const last = stops[stops.length - 1];
        return `rgb(${last.color[0]}, ${last.color[1]}, ${last.color[2]})`;
      }

      function computeValueRatio(value, min, max) {
        if (!Number.isFinite(value) || !Number.isFinite(min) || !Number.isFinite(max) || min === max) {
          return null;
        }
        if (value <= min) {
          return 0;
        }
        if (value >= max) {
          return 1;
        }
        return (value - min) / (max - min);
      }

      function valueToColor(value, min, max) {
        if (!Number.isFinite(value)) {
          return "#dee2e6";
        }
        if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) {
          return toRgbString(COLOR_GREEN);
        }
        if (value <= min) {
          return toRgbString(COLOR_GREEN);
        }
        if (value >= max) {
          return toRgbString(COLOR_RED);
        }
        const ratio = (value - min) / (max - min);
        return interpolateGradient(GRADIENT_STOPS, ratio);
      }

      function valueToTextColor(value, min, max) {
        const ratio = computeValueRatio(value, min, max);
        if (ratio === null) {
          return "#212529";
        }
        return ratio >= 0.75 ? "#ffffff" : "#212529";
      }

      function updateHeatmap() {
        heatmapContainer.innerHTML = "";
        if (!selectedDevice) {
          heatmapContainer.innerHTML = `<div class="heatmap-placeholder">选择设备以查看压力分布</div>`;
          return;
        }
        const entry = state.get(selectedDevice);
        if (!entry) {
          heatmapContainer.innerHTML = `<div class="heatmap-placeholder">等待设备数据更新...</div>`;
          return;
        }
        const layout = parseLayoutKey(selectedLayoutKey);
        if (!layout) {
          heatmapContainer.innerHTML = `<div class="heatmap-placeholder">请选择行列组合</div>`;
          return;
        }
        const [rows, cols] = layout;
        const totalCells = rows * cols;
        const values = Array.isArray(entry.pressureValues) ? [...entry.pressureValues] : [];
        if (values.length > totalCells) {
          values.length = totalCells;
        }
        while (values.length < totalCells) {
          values.push(NaN);
        }
        const validValues = values.filter((value) => Number.isFinite(value));
        const hasValidValues = validValues.length > 0;
        const dataMin = hasValidValues ? Math.min(...validValues) : null;
        const dataMax = hasValidValues ? Math.max(...validValues) : null;
        updateRangePlaceholders(dataMin, dataMax);
        const { min: resolvedMin, max: resolvedMax } = resolveEffectiveRange(dataMin, dataMax);
        const min = Number.isFinite(resolvedMin) ? resolvedMin : 0;
        const max = Number.isFinite(resolvedMax) ? resolvedMax : min;

        const grid = document.createElement("div");
        grid.className = "heatmap-grid";
        grid.style.setProperty("--rows", rows);
        grid.style.setProperty("--cols", cols);

        values.forEach((value) => {
          const cell = document.createElement("div");
          cell.className = "heatmap-cell";
          if (Number.isFinite(value)) {
            cell.textContent = value.toFixed(2);
            cell.style.backgroundColor = valueToColor(value, min, max);
            cell.style.color = valueToTextColor(value, min, max);
            cell.title = `压力值：${value}`;
          } else {
            cell.classList.add("is-empty");
            cell.textContent = "--";
            cell.title = "缺少压力数据";
          }
          grid.appendChild(cell);
        });

        heatmapContainer.appendChild(grid);
      }

      function updateLayoutOptions() {
        layoutSelector.innerHTML = "";
        const entry = selectedDevice ? state.get(selectedDevice) : null;
        if (!entry || !Number.isInteger(entry.sensorCount) || entry.sensorCount <= 0) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "--";
          layoutSelector.appendChild(option);
          layoutSelector.disabled = true;
          selectedLayoutKey = null;
          updateHeatmap();
          return;
        }

        const pairs = computeFactorPairs(entry.sensorCount);
        if (!pairs.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "--";
          layoutSelector.appendChild(option);
          layoutSelector.disabled = true;
          selectedLayoutKey = null;
          updateHeatmap();
          return;
        }

        let defaultKey = chooseDefaultLayout(pairs);
        const previous = selectedLayoutKey;
        pairs.forEach(([rows, cols]) => {
          const key = `${rows}x${cols}`;
          const option = document.createElement("option");
          option.value = key;
          option.textContent = `${rows} × ${cols}`;
          layoutSelector.appendChild(option);
        });

        const hasPrevious = previous && pairs.some(([rows, cols]) => `${rows}x${cols}` === previous);
        selectedLayoutKey = hasPrevious ? previous : defaultKey;
        layoutSelector.value = selectedLayoutKey || "";
        layoutSelector.disabled = pairs.length <= 1;
        updateHeatmap();
      }

      function updateDeviceOptions() {
        const previous = selectedDevice;
        const devices = Array.from(state.keys()).sort();
        deviceSelector.innerHTML = "";
        if (!devices.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "等待数据...";
          deviceSelector.appendChild(option);
          deviceSelector.disabled = true;
          selectedDevice = null;
          updateLayoutOptions();
          return;
        }

        devices.forEach((dn) => {
          const option = document.createElement("option");
          option.value = dn;
          option.textContent = dn;
          deviceSelector.appendChild(option);
        });

        if (previous && devices.includes(previous)) {
          selectedDevice = previous;
        } else if (!selectedDevice || !devices.includes(selectedDevice)) {
          selectedDevice = devices[0];
        }

        deviceSelector.value = selectedDevice;
        deviceSelector.disabled = false;
        updateLayoutOptions();
      }

      function updateSummary() {
        const now = Date.now();
        let active = 0;
        let total = 0;
        for (const entry of state.values()) {
          if (Number.isFinite(entry.pressureSum)) {
            total += entry.pressureSum;
          }
          if (entry.receivedAt && now - entry.receivedAt <= STALE_THRESHOLD_MS) {
            active += 1;
          }
        }
        document.getElementById("active-devices").textContent = active;
        document.getElementById("total-pressure").textContent = total.toFixed(2);
      }

      function updateLastUpdateIndicator() {
        const lastUpdate = document.getElementById("last-update");
        const latest = Array.from(state.values()).reduce(
          (max, entry) => Math.max(max, entry.receivedAt || 0),
          0
        );
        lastUpdate.textContent = latest ? new Date(latest).toLocaleString() : "--";
      }

      function refreshUI() {
        updateSummary();
        updateTable();
        updateDeviceOptions();
        updateLastUpdateIndicator();
      }

      function updateTable() {
        const tbody = document.querySelector("#device-table tbody");
        const autoScroll = document.getElementById("autoScroll").checked;
        const now = Date.now();
        const rows = Array.from(state.values()).sort((a, b) => {
          if (a.dn && b.dn && a.dn.localeCompare) {
            return a.dn.localeCompare(b.dn, undefined, { numeric: true, sensitivity: "base" });
          }
          if (a.dn < b.dn) return -1;
          if (a.dn > b.dn) return 1;
          return 0;
        });
        tbody.innerHTML = "";
        for (const entry of rows) {
          const tr = document.createElement("tr");
          const isStale = !entry.receivedAt || now - entry.receivedAt > STALE_THRESHOLD_MS;
          if (isStale) {
            tr.classList.add("text-muted");
          }
          const pressureText = Number.isFinite(entry.pressureSum) ? entry.pressureSum.toFixed(2) : "--";
          tr.innerHTML = `
            <td><code>${entry.dn}</code></td>
            <td>${entry.sensorCount ?? "--"}</td>
            <td>${pressureText}</td>
            <td>${entry.frameTime ? new Date(entry.frameTime).toLocaleString() : "--"}</td>
            <td>${entry.receivedAt ? new Date(entry.receivedAt).toLocaleString() : "--"}</td>
            <td class="text-center">
              <button type="button" class="btn btn-sm btn-outline-danger remove-device" data-dn="${entry.dn}">停止监控</button>
            </td>
          `;
          const removeButton = tr.querySelector(".remove-device");
          if (removeButton) {
            removeButton.addEventListener("click", (event) => {
              event.stopPropagation();
              removeDevice(entry.dn);
            });
          }
          tbody.appendChild(tr);
        }
        if (autoScroll) {
          tbody.parentElement.scrollTop = 0;
        }
      }

      function removeDevice(dn) {
        if (!state.has(dn)) {
          return;
        }
        state.delete(dn);
        if (selectedDevice === dn) {
          selectedDevice = null;
        }
        refreshUI();
      }

      function normalizeEntry(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const dn = entry.dn || "UNKNOWN";
        const payload = entry.payload || {};
        let pressureSum = null;
        let sensorCount = null;
        let frameTime = null;
        let pressureValues = [];
        if (payload && typeof payload === "object") {
          const rawPressures = Array.isArray(payload.p) ? payload.p : [];
          const numericPressures = rawPressures.map((value) => {
            const num = Number(value);
            return Number.isFinite(num) ? num : NaN;
          });
          const declaredCount = Number(payload.sn);
          if (Number.isInteger(declaredCount) && declaredCount > 0) {
            sensorCount = declaredCount;
          } else {
            sensorCount = numericPressures.length;
          }
          pressureValues = numericPressures.slice(0, sensorCount);
          while (pressureValues.length < sensorCount) {
            pressureValues.push(NaN);
          }
          pressureSum = pressureValues.reduce(
            (acc, value) => acc + (Number.isFinite(value) ? value : 0),
            0
          );
          if (payload.ts) {
            frameTime = payload.ts * 1000;
          }
        }
        const receivedAt = entry.received_at ? Date.parse(entry.received_at) : Date.now();
        return {
          dn,
          pressureSum,
          sensorCount,
          frameTime,
          receivedAt,
          pressureValues,
          raw: entry
        };
      }

      function applyEntry(entry, options = {}) {
        const normalized = normalizeEntry(entry);
        if (!normalized) return;
        state.set(normalized.dn, normalized);
        if (options.defer) {
          return;
        }
        refreshUI();
      }

      async function fetchSnapshot() {
        try {
          const resp = await fetch(SNAPSHOT_ENDPOINT);
          const data = await resp.json();
          if (Array.isArray(data.data)) {
            data.data.forEach((item) => applyEntry(item, { defer: true }));
            refreshUI();
          }
          document.getElementById("status-indicator").textContent = "已连接";
          document.getElementById("status-indicator").classList.remove("bg-secondary", "bg-danger");
          document.getElementById("status-indicator").classList.add("bg-success");
        } catch (err) {
          document.getElementById("status-indicator").textContent = "桥接不可达";
          document.getElementById("status-indicator").classList.remove("bg-secondary", "bg-success");
          document.getElementById("status-indicator").classList.add("bg-danger");
          console.error("无法获取快照", err);
        }
      }

      function subscribeStream() {
        const source = new EventSource(STREAM_ENDPOINT);
        source.addEventListener("snapshot", (event) => {
          try {
            const payload = JSON.parse(event.data);
            if (Array.isArray(payload.data)) {
              payload.data.forEach((item) => applyEntry(item, { defer: true }));
              refreshUI();
            }
          } catch (err) {
            console.error("解析 snapshot 数据失败", err);
          }
        });
        source.addEventListener("update", (event) => {
          try {
            const payload = JSON.parse(event.data);
            applyEntry(payload);
          } catch (err) {
            console.error("解析 update 数据失败", err);
          }
        });
        source.addEventListener("error", (event) => {
          document.getElementById("status-indicator").textContent = "实时连接中断";
          document.getElementById("status-indicator").classList.remove("bg-success");
          document.getElementById("status-indicator").classList.add("bg-warning");
        });
        source.onopen = () => {
          document.getElementById("status-indicator").textContent = "实时连接正常";
          document.getElementById("status-indicator").classList.remove("bg-secondary", "bg-danger", "bg-warning");
          document.getElementById("status-indicator").classList.add("bg-success");
        };
      }

      fetchSnapshot();
      subscribeStream();
    </script>
  </body>
</html>
