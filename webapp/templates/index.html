<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>リアルタイム圧力モニター</title>

    <!-- 去掉 integrity / crossorigin -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    />

    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body>
    <!-- Main dashboard wrapper: controls header + heatmap + stats -->
    <!-- 主仪表盘容器：包含头部、热力图与统计信息 -->
    <div class="container py-4">
      <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
        <div>
          <h1 class="h3 mb-1" data-i18n="header.title">实时压力监控面板</h1>
          <p class="text-muted mb-0">
            <span data-i18n="header.data_source">数据来源：</span><code>{{ bridge_api_base }}</code>
          </p>
        </div>
        <div class="text-md-end">
          <div class="btn-group btn-group-sm language-switcher mb-2" role="group" id="language-switcher">
            <button type="button" class="btn btn-outline-secondary" data-lang="ja">日本語</button>
            <button type="button" class="btn btn-outline-secondary" data-lang="en">English</button>
            <button type="button" class="btn btn-outline-secondary" data-lang="zh">中文</button>
          </div>
          <div class="badge bg-secondary d-block" id="status-indicator" data-i18n="status.connecting">连接中...</div>
          <div class="small text-muted" id="last-update">--</div>
        </div>
      </div>
  
      <!-- Heatmap + detail cards region -->
      <!-- 热力图与详情卡片区域 -->
      <div class="row g-4">
        <div class="col-lg-8">
          <div class="card shadow-sm h-100">
            <div class="card-body">
              <div class="d-flex flex-column flex-xl-row align-items-xl-center justify-content-between gap-3 mb-3">
                <h2 class="h5 mb-0" data-i18n="heatmap.heading">压力热力图</h2>
                <div class="w-100">
                  <div class="row gy-2 gx-2 align-items-stretch heatmap-controls">
                    <div class="col-12 col-md-6 col-xl-auto">
                      <div class="input-group">
                        <span class="input-group-text" data-i18n="controls.device">设备</span>
                        <select class="form-select" id="device-selector" disabled>
                          <option value="">等待数据...</option>
                        </select>
                      </div>
                    </div>
                    <div class="col-12 col-md-6 col-xl-auto">
                      <div class="input-group">
                        <span class="input-group-text" data-i18n="controls.layout">布局</span>
                        <select class="form-select" id="layout-selector" disabled>
                          <option value="">--</option>
                        </select>
                      </div>
                    </div>
                    <div class="col-12 col-md-6 col-xl-auto">
                      <div class="mirror-toggle-group d-flex flex-wrap align-items-center gap-3">
                        <div class="form-check form-switch mb-0">
                          <input class="form-check-input" type="checkbox" id="mirror-rows" />
                          <label class="form-check-label" for="mirror-rows" data-i18n="controls.mirror_rows">行镜像</label>
                        </div>
                        <div class="form-check form-switch mb-0">
                          <input class="form-check-input" type="checkbox" id="mirror-cols" />
                          <label class="form-check-label" for="mirror-cols" data-i18n="controls.mirror_cols">列镜像</label>
                        </div>
                      </div>
                    </div>
                    <div class="col-12">
                      <div class="pressure-range-group">
                        <div class="row gy-2 gx-2 align-items-center">
                          <div class="col-12">
                            <div class="fw-semibold text-secondary" data-i18n="controls.range">压力范围</div>
                          </div>
                          <div class="col-12 col-sm-6 col-md-4 col-xl-3">
                            <label class="visually-hidden" for="pressure-min" data-i18n="inputs.lower_label">压力下限</label>
                            <div class="input-group">
                              <span class="input-group-text" data-i18n="inputs.lower_label">下限</span>
                              <input
                                type="number"
                                class="form-control"
                                id="pressure-min"
                                placeholder="下限"
                                data-i18n-placeholder="inputs.placeholder.lower"
                                step="any"
                              />
                            </div>
                          </div>
                          <div class="col-12 col-sm-6 col-md-4 col-xl-3">
                            <label class="visually-hidden" for="pressure-max" data-i18n="inputs.upper_label">压力上限</label>
                            <div class="input-group">
                              <span class="input-group-text" data-i18n="inputs.upper_label">上限</span>
                              <input
                                type="number"
                                class="form-control"
                                id="pressure-max"
                                placeholder="上限"
                                data-i18n-placeholder="inputs.placeholder.upper"
                                step="any"
                              />
                            </div>
                          </div>
                          <div class="col-12 col-sm-auto">
                            <button class="btn btn-outline-secondary w-100 w-sm-auto" type="button" id="reset-range" data-i18n="actions.reset">
                              重置
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div id="heatmap-container">
                <div class="heatmap-placeholder" data-i18n="heatmap.empty.waiting">等待数据...</div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-4">
          <div class="card shadow-sm h-100">
            <div class="card-body">
              <h2 class="h5 mb-3" data-i18n="overview.title">当前概览</h2>
              <div class="mb-3">
                <div class="fw-semibold" data-i18n="overview.active_devices">活跃设备</div>
                <div class="display-6" id="active-devices">0</div>
              </div>
              <div>
                <div class="fw-semibold" data-i18n="overview.total_pressure">总压力</div>
                <div class="display-6" id="total-pressure">0</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Device table showing latest snapshot per DN -->
      <!-- 设备表：展示每个 DN 的最新快照 -->
      <div class="card shadow-sm mt-4">
        <div class="card-body">
          <h2 class="h5 mb-3" data-i18n="table.title">设备详情</h2>
          <div class="table-responsive" style="max-height: 360px;">
            <table class="table table-striped align-middle" id="device-table">
              <thead class="table-light sticky-top">
                <tr>
                  <th scope="col" data-i18n="table.headers.dn">DN</th>
                  <th scope="col" data-i18n="table.headers.count">压力传感器数</th>
                  <th scope="col" data-i18n="table.headers.sum">压力总和</th>
                  <th scope="col" data-i18n="table.headers.frame_time">最新帧时间</th>
                  <th scope="col" data-i18n="table.headers.receive_time">接收时间</th>
                  <th scope="col" class="text-center" data-i18n="table.headers.actions">操作</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <!-- Front-end logic: state management, i18n, SSE subscriptions -->
    <!-- 前端逻辑：状态管理、多语言与 SSE 订阅 -->
    <script>
      // Front-end state setup & DOM references. Keeps real-time UI consistent.
      // 前端状态与 DOM 引用定义，用于维持实时界面一致性。
      const SNAPSHOT_ENDPOINT = "{{ url_for('proxy_latest') }}";
      const STREAM_ENDPOINT = "{{ url_for('proxy_stream') }}";

      const state = new Map();
      const mirrorSettingsByDevice = new Map();
      const STALE_THRESHOLD_MS = 30 * 1000;
      const deviceSelector = document.getElementById("device-selector");
      const layoutSelector = document.getElementById("layout-selector");
      const heatmapContainer = document.getElementById("heatmap-container");
      const pressureMinInput = document.getElementById("pressure-min");
      const pressureMaxInput = document.getElementById("pressure-max");
      const resetRangeButton = document.getElementById("reset-range");
      const mirrorRowsToggle = document.getElementById("mirror-rows");
      const mirrorColsToggle = document.getElementById("mirror-cols");
      const statusIndicator = document.getElementById("status-indicator");
      const activeDevicesLabel = document.getElementById("active-devices");
      const totalPressureLabel = document.getElementById("total-pressure");
      const lastUpdateLabel = document.getElementById("last-update");
      const languageButtons = document.querySelectorAll("#language-switcher [data-lang]");
      let selectedDevice = null;
      let selectedLayoutKey = null;
      let customRangeMin = null;
      let customRangeMax = null;
      let mirrorRows = false;
      let mirrorCols = false;
      const REFRESH_INTERVAL_MS = 250;
      const SNAPSHOT_POLL_INTERVAL_MS = 30000;
      const STREAM_RECONNECT_BASE_DELAY_MS = 2000;
      const STREAM_RECONNECT_MAX_DELAY_MS = 15000;
      let pendingRefresh = false;
      let refreshTimerId = null;
      let lastRefreshTimestamp = 0;
      let snapshotPollTimerId = null;
      let currentEventSource = null;
      let streamReconnectTimerId = null;
      let streamReconnectAttempts = 0;
      let deviceOptionsCache = { devices: [], selected: null, lang: null };
      let layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: null };

      // --- Stream lifecycle helpers: manage SSE backoff/retry flow ---
      // --- 流式连接辅助：管理 SSE 回退与重连流程 ---
      function clearStreamReconnectTimer() {
        if (streamReconnectTimerId !== null) {
          window.clearTimeout(streamReconnectTimerId);
          streamReconnectTimerId = null;
        }
      }

      function scheduleStreamReconnect() {
        if (streamReconnectTimerId !== null) {
          return;
        }
        const delay = Math.min(
          STREAM_RECONNECT_BASE_DELAY_MS * Math.max(1, Math.pow(2, streamReconnectAttempts)),
          STREAM_RECONNECT_MAX_DELAY_MS
        );
        streamReconnectTimerId = window.setTimeout(() => {
          streamReconnectTimerId = null;
          streamReconnectAttempts += 1;
          subscribeStream();
        }, delay);
      }

      function cleanupEventSource() {
        if (currentEventSource) {
          currentEventSource.close();
          currentEventSource = null;
        }
      }

      // Compare simple arrays for option caching, avoiding unnecessary DOM churn.
      // 比较简单数组，若相同则避免重复刷新 DOM。
      function arraysEqual(left, right) {
        if (left.length !== right.length) {
          return false;
        }
        for (let i = 0; i < left.length; i += 1) {
          if (left[i] !== right[i]) {
            return false;
          }
        }
        return true;
      }

      const COLOR_GREEN = [46, 204, 113];
      const COLOR_YELLOW = [241, 196, 15];
      const COLOR_ORANGE = [243, 156, 18];
      const COLOR_RED = [231, 76, 60];

      const GRADIENT_STOPS = [
        { stop: 0, color: COLOR_GREEN },
        { stop: 0.33, color: COLOR_YELLOW },
        { stop: 0.66, color: COLOR_ORANGE },
        { stop: 1, color: COLOR_RED }
      ];

      const LANGUAGE_META = {
        zh: { locale: "zh-CN" },
        ja: { locale: "ja-JP" },
        en: { locale: "en" }
      };

      const TRANSLATIONS = {
        zh: {
          "page.title": "实时压力监控面板",
          "header.title": "实时压力监控面板",
          "header.data_source": "数据来源：",
          "status.connecting": "连接中...",
          "status.snapshot_ok": "已连接",
          "status.snapshot_error": "桥接不可用",
          "status.stream_error": "实时连接中断",
          "status.stream_ok": "实时连接已建立",
          "heatmap.heading": "压力热力图",
          "controls.device": "设备",
          "controls.layout": "布局",
          "controls.mirror_rows": "行镜像",
          "controls.mirror_cols": "列镜像",
          "controls.range": "压力范围",
          "controls.waiting": "等待数据...",
          "inputs.lower_label": "下限",
          "inputs.upper_label": "上限",
          "inputs.placeholder.lower": "下限",
          "inputs.placeholder.upper": "上限",
          "actions.reset": "重置",
          "overview.title": "当前概览",
          "overview.active_devices": "活跃设备",
          "overview.total_pressure": "总压力",
          "table.title": "设备详情",
          "table.headers.dn": "DN",
          "table.headers.count": "压力传感器数",
          "table.headers.sum": "压力总和",
          "table.headers.frame_time": "最新帧时间",
          "table.headers.receive_time": "接收时间",
          "table.headers.actions": "操作",
          "table.actions.stop_tracking": "停止追踪",
          "heatmap.empty.no_device": "选择设备以查看压力热力图",
          "heatmap.empty.no_layout": "请选择布局组合",
          "heatmap.empty.waiting": "等待设备数据更新...",
          "heatmap.tooltip.value": "压力值：",
          "heatmap.tooltip.missing": "缺少压力数据",
          "console.snapshot_fetch_failed": "无法获取数据",
          "console.snapshot_event_error": "解析快照事件失败",
          "console.update_event_error": "解析更新事件失败"
        },
        ja: {
          "page.title": "リアルタイム圧力モニター",
          "header.title": "リアルタイム圧力モニター",
          "header.data_source": "データソース：",
          "status.connecting": "接続中...",
          "status.snapshot_ok": "スナップショットを取得",
          "status.snapshot_error": "ブリッジに接続できません",
          "status.stream_error": "リアルタイム接続が中断しました",
          "status.stream_ok": "リアルタイム接続が確立されました",
          "heatmap.heading": "圧力ヒートマップ",
          "controls.device": "デバイス",
          "controls.layout": "レイアウト",
          "controls.mirror_rows": "行を反転",
          "controls.mirror_cols": "列を反転",
          "controls.range": "圧力範囲",
          "controls.waiting": "データ待機中...",
          "inputs.lower_label": "下限",
          "inputs.upper_label": "上限",
          "inputs.placeholder.lower": "下限",
          "inputs.placeholder.upper": "上限",
          "actions.reset": "リセット",
          "overview.title": "概要",
          "overview.active_devices": "アクティブデバイス",
          "overview.total_pressure": "総圧力",
          "table.title": "デバイス詳細",
          "table.headers.dn": "DN",
          "table.headers.count": "センサー数",
          "table.headers.sum": "圧力合計",
          "table.headers.frame_time": "最新フレーム時刻",
          "table.headers.receive_time": "受信時刻",
          "table.headers.actions": "操作",
          "table.actions.stop_tracking": "監視を停止",
          "heatmap.empty.no_device": "デバイスを選択してヒートマップを表示",
          "heatmap.empty.no_layout": "レイアウトを選択してください",
          "heatmap.empty.waiting": "デバイスデータの更新を待機中...",
          "heatmap.tooltip.value": "圧力値：",
          "heatmap.tooltip.missing": "圧力データなし",
          "console.snapshot_fetch_failed": "データを取得できませんでした",
          "console.snapshot_event_error": "スナップショットイベントの解析に失敗しました",
          "console.update_event_error": "アップデートイベントの解析に失敗しました"
        },
        en: {
          "page.title": "Real-Time Pressure Dashboard",
          "header.title": "Real-Time Pressure Dashboard",
          "header.data_source": "Data source: ",
          "status.connecting": "Connecting...",
          "status.snapshot_ok": "Snapshot loaded",
          "status.snapshot_error": "Bridge unavailable",
          "status.stream_error": "Realtime feed interrupted",
          "status.stream_ok": "Realtime feed active",
          "heatmap.heading": "Pressure Heatmap",
          "controls.device": "Device",
          "controls.layout": "Layout",
          "controls.mirror_rows": "Mirror rows",
          "controls.mirror_cols": "Mirror columns",
          "controls.range": "Pressure range",
          "controls.waiting": "Waiting for data...",
          "inputs.lower_label": "Min",
          "inputs.upper_label": "Max",
          "inputs.placeholder.lower": "Min",
          "inputs.placeholder.upper": "Max",
          "actions.reset": "Reset",
          "overview.title": "Overview",
          "overview.active_devices": "Active devices",
          "overview.total_pressure": "Total pressure",
          "table.title": "Device Details",
          "table.headers.dn": "DN",
          "table.headers.count": "Sensor count",
          "table.headers.sum": "Pressure total",
          "table.headers.frame_time": "Latest frame time",
          "table.headers.receive_time": "Received at",
          "table.headers.actions": "Actions",
          "table.actions.stop_tracking": "Stop tracking",
          "heatmap.empty.no_device": "Select a device to view the heatmap",
          "heatmap.empty.no_layout": "Choose a layout",
          "heatmap.empty.waiting": "Waiting for device data...",
          "heatmap.tooltip.value": "Pressure: ",
          "heatmap.tooltip.missing": "No pressure data",
          "console.snapshot_fetch_failed": "Failed to fetch data",
          "console.snapshot_event_error": "Failed to parse snapshot event",
          "console.update_event_error": "Failed to parse update event"
        }
      };
      let currentLanguage = localStorage.getItem("uiLanguage") || "ja";
      if (!Object.prototype.hasOwnProperty.call(TRANSLATIONS, currentLanguage)) {
        currentLanguage = "ja";
      }
      let currentStatusKey = "connecting";

      // --- Internationalization helpers: resolve localized strings on demand ---
      // --- 多语言辅助：按需解析文案 ---
      function t(key) {
        const pack = TRANSLATIONS[currentLanguage] || TRANSLATIONS.ja;
        if (Object.prototype.hasOwnProperty.call(pack, key)) {
          return pack[key];
        }
        return TRANSLATIONS.ja[key] ?? key;
      }

      function updateStatusIndicatorText() {
        if (!statusIndicator) {
          return;
        }
        statusIndicator.textContent = t(`status.${currentStatusKey}`);
      }

      function setStatusIndicator(stateKey) {
        currentStatusKey = stateKey;
        updateStatusIndicatorText();
      }

      function updateLanguageSwitcherState() {
        languageButtons.forEach((button) => {
          const isActive = button.dataset.lang === currentLanguage;
          button.classList.toggle("btn-primary", isActive);
          button.classList.toggle("btn-outline-secondary", !isActive);
          button.setAttribute("aria-pressed", String(isActive));
        });
      }

      function applyLanguage() {
        const locale = LANGUAGE_META[currentLanguage]?.locale || "ja-JP";
        document.documentElement.lang = locale;
        document.title = t("page.title");
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.dataset.i18n;
          if (!key) return;
          const translation = t(key);
          if (translation !== undefined) {
            el.textContent = translation;
          }
        });
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.dataset.i18nPlaceholder;
          if (!key) return;
          const translation = t(key);
          if (translation !== undefined) {
            el.setAttribute("placeholder", translation);
          }
        });
        updateStatusIndicatorText();
        updateLanguageSwitcherState();
        updateRangePlaceholders(null, null);
      }

      function setLanguage(lang) {
        if (!Object.prototype.hasOwnProperty.call(TRANSLATIONS, lang)) {
          return;
        }
        currentLanguage = lang;
        localStorage.setItem("uiLanguage", lang);
        applyLanguage();
        refreshUI();
      }

      languageButtons.forEach((button) => {
        button.addEventListener("click", () => {
          setLanguage(button.dataset.lang);
        });
      });

      deviceSelector.addEventListener("change", (event) => {
        selectedDevice = event.target.value || null;
        deviceOptionsCache.selected = selectedDevice;
        updateLayoutOptions();
      });

      layoutSelector.addEventListener("change", (event) => {
        selectedLayoutKey = event.target.value || null;
        updateHeatmap();
      });

      if (mirrorRowsToggle) {
        mirrorRowsToggle.addEventListener("change", (event) => {
          mirrorRows = Boolean(event.target.checked);
          persistMirrorSettings();
          updateHeatmap();
        });
      }

      if (mirrorColsToggle) {
        mirrorColsToggle.addEventListener("change", (event) => {
          mirrorCols = Boolean(event.target.checked);
          persistMirrorSettings();
          updateHeatmap();
        });
      }

      if (pressureMinInput && pressureMaxInput) {
        ["input", "change"].forEach((eventName) => {
          pressureMinInput.addEventListener(eventName, handleCustomRangeChange);
          pressureMaxInput.addEventListener(eventName, handleCustomRangeChange);
        });
      }

      if (resetRangeButton) {
        resetRangeButton.addEventListener("click", () => {
          if (pressureMinInput) {
            pressureMinInput.value = "";
            pressureMinInput.classList.remove("is-invalid");
          }
          if (pressureMaxInput) {
            pressureMaxInput.value = "";
            pressureMaxInput.classList.remove("is-invalid");
          }
          customRangeMin = null;
          customRangeMax = null;
          updateHeatmap();
        });
      }

      // --- Heatmap layout utilities: derive possible row/col pairs ---
      // --- 热力图布局工具：根据传感器数量推导行列组合 ---
      function computeFactorPairs(sn) {
        if (!Number.isInteger(sn) || sn <= 0) {
          return [];
        }
        const basePairs = [];
        const limit = Math.floor(Math.sqrt(sn));
        for (let i = 1; i <= limit; i += 1) {
          if (sn % i === 0) {
            basePairs.push([i, sn / i]);
          }
        }
        const pairs = [];
        basePairs.forEach(([rows, cols]) => {
          pairs.push([rows, cols]);
          if (rows !== cols) {
            pairs.push([cols, rows]);
          }
        });
        pairs.sort((a, b) => {
          const diffA = Math.abs(a[0] - a[1]);
          const diffB = Math.abs(b[0] - b[1]);
          if (diffA !== diffB) return diffA - diffB;
          if (a[0] !== b[0]) return a[0] - b[0];
          return a[1] - b[1];
        });
        return pairs;
      }

      function chooseDefaultLayout(pairs) {
        if (!pairs.length) {
          return null;
        }
        return `${pairs[0][0]}x${pairs[0][1]}`;
      }

      function parseLayoutKey(key) {
        if (!key) {
          return null;
        }
        const [rows, cols] = key.split("x").map((value) => Number(value));
        if (!Number.isInteger(rows) || !Number.isInteger(cols)) {
          return null;
        }
        return [rows, cols];
      }

      function handleCustomRangeChange() {
        if (!pressureMinInput || !pressureMaxInput) {
          return;
        }
        const rawMin = pressureMinInput.value.trim();
        const rawMax = pressureMaxInput.value.trim();
        const hasMin = rawMin !== "";
        const hasMax = rawMax !== "";
        const minValue = Number(rawMin);
        const maxValue = Number(rawMax);
        const minValid = !hasMin || Number.isFinite(minValue);
        const maxValid = !hasMax || Number.isFinite(maxValue);

        pressureMinInput.classList.remove("is-invalid");
        pressureMaxInput.classList.remove("is-invalid");

        if (!minValid || !maxValid) {
          if (!minValid) {
            pressureMinInput.classList.add("is-invalid");
          }
          if (!maxValid) {
            pressureMaxInput.classList.add("is-invalid");
          }
          customRangeMin = null;
          customRangeMax = null;
          updateHeatmap();
          return;
        }

        if (hasMin && hasMax) {
          if (minValue < maxValue) {
            customRangeMin = minValue;
            customRangeMax = maxValue;
          } else {
            pressureMinInput.classList.add("is-invalid");
            pressureMaxInput.classList.add("is-invalid");
            customRangeMin = null;
            customRangeMax = null;
            updateHeatmap();
            return;
          }
        } else {
          customRangeMin = null;
          customRangeMax = null;
        }

        updateHeatmap();
      }

      function updateRangePlaceholders(dataMin, dataMax) {
        if (pressureMinInput) {
          if (Number.isFinite(dataMin)) {
            pressureMinInput.placeholder = dataMin.toFixed(2);
          } else {
            pressureMinInput.placeholder = t("inputs.placeholder.lower");
          }
        }
        if (pressureMaxInput) {
          if (Number.isFinite(dataMax)) {
            pressureMaxInput.placeholder = dataMax.toFixed(2);
          } else {
            pressureMaxInput.placeholder = t("inputs.placeholder.upper");
          }
        }
      }

      function resolveEffectiveRange(dataMin, dataMax) {
        if (
          Number.isFinite(customRangeMin) &&
          Number.isFinite(customRangeMax) &&
          customRangeMin < customRangeMax
        ) {
          return { min: customRangeMin, max: customRangeMax };
        }
        if (Number.isFinite(dataMin) && Number.isFinite(dataMax)) {
          return { min: dataMin, max: dataMax };
        }
        return { min: 0, max: 0 };
      }

      function toRgbString(color) {
        return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
      }

      function interpolateGradient(stops, ratio) {
        const clamped = Math.min(1, Math.max(0, ratio));
        for (let i = 1; i < stops.length; i += 1) {
          if (clamped <= stops[i].stop) {
            const prev = stops[i - 1];
            const next = stops[i];
            const span = next.stop - prev.stop || 1;
            const localT = span === 0 ? 0 : (clamped - prev.stop) / span;
            const r = Math.round(prev.color[0] + (next.color[0] - prev.color[0]) * localT);
            const g = Math.round(prev.color[1] + (next.color[1] - prev.color[1]) * localT);
            const b = Math.round(prev.color[2] + (next.color[2] - prev.color[2]) * localT);
            return `rgb(${r}, ${g}, ${b})`;
          }
        }
        const last = stops[stops.length - 1];
        return `rgb(${last.color[0]}, ${last.color[1]}, ${last.color[2]})`;
      }

      function computeValueRatio(value, min, max) {
        if (!Number.isFinite(value) || !Number.isFinite(min) || !Number.isFinite(max) || min === max) {
          return null;
        }
        if (value <= min) {
          return 0;
        }
        if (value >= max) {
          return 1;
        }
        return (value - min) / (max - min);
      }

      function valueToColor(value, min, max) {
        if (!Number.isFinite(value)) {
          return "#dee2e6";
        }
        if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) {
          return toRgbString(COLOR_GREEN);
        }
        if (value <= min) {
          return toRgbString(COLOR_GREEN);
        }
        if (value >= max) {
          return toRgbString(COLOR_RED);
        }
        const ratio = (value - min) / (max - min);
        return interpolateGradient(GRADIENT_STOPS, ratio);
      }

      function valueToTextColor(value, min, max) {
        const ratio = computeValueRatio(value, min, max);
        if (ratio === null) {
          return "#212529";
        }
        return ratio >= 0.75 ? "#ffffff" : "#212529";
      }

      function applyMirroring(values, rows, cols) {
        if (!rows || !cols) {
          return values.slice();
        }
        const result = [];
        for (let displayRow = 0; displayRow < rows; displayRow += 1) {
          const sourceRow = mirrorRows ? rows - 1 - displayRow : displayRow;
          const start = sourceRow * cols;
          const rowValues = values.slice(start, start + cols);
          if (mirrorCols) {
            rowValues.reverse();
          }
          result.push(...rowValues);
        }
        return result;
      }

      function persistMirrorSettings() {
        if (!selectedDevice) {
          return;
        }
        mirrorSettingsByDevice.set(selectedDevice, {
          rows: mirrorRows,
          cols: mirrorCols
        });
      }

      function syncMirrorControlsFromState() {
        if (!mirrorRowsToggle || !mirrorColsToggle) {
          mirrorRows = false;
          mirrorCols = false;
          return;
        }
        const settings = selectedDevice ? mirrorSettingsByDevice.get(selectedDevice) : null;
        mirrorRows = settings ? Boolean(settings.rows) : false;
        mirrorCols = settings ? Boolean(settings.cols) : false;
      mirrorRowsToggle.checked = mirrorRows;
      mirrorColsToggle.checked = mirrorCols;
    }

      function setHeatmapPlaceholder(key) {
        heatmapContainer.innerHTML = `<div class="heatmap-placeholder">${t(key)}</div>`;
      }

      // Render the heatmap SVG + controls based on latest device selection.
      // 根据当前设备选择渲染热力图 SVG 及控制项。
      function updateHeatmap() {
        heatmapContainer.innerHTML = "";
        if (!selectedDevice) {
          setHeatmapPlaceholder("heatmap.empty.no_device");
          return;
        }
        const entry = state.get(selectedDevice);
        if (!entry) {
          setHeatmapPlaceholder("heatmap.empty.waiting");
          return;
        }
        const layout = parseLayoutKey(selectedLayoutKey);
        if (!layout) {
          setHeatmapPlaceholder("heatmap.empty.no_layout");
          return;
        }
        const [rows, cols] = layout;
        const totalCells = rows * cols;
        const values = Array.isArray(entry.pressureValues) ? [...entry.pressureValues] : [];
        if (values.length > totalCells) {
          values.length = totalCells;
        }
        const paddedValues = values.slice();
        while (paddedValues.length < totalCells) {
          paddedValues.push(NaN);
        }
        const displayValues = applyMirroring(paddedValues, rows, cols);
        const validValues = paddedValues.filter((value) => Number.isFinite(value));
        const hasValidValues = validValues.length > 0;
        const dataMin = hasValidValues ? Math.min(...validValues) : null;
        const dataMax = hasValidValues ? Math.max(...validValues) : null;
        updateRangePlaceholders(dataMin, dataMax);
        const { min: resolvedMin, max: resolvedMax } = resolveEffectiveRange(dataMin, dataMax);
        const min = Number.isFinite(resolvedMin) ? resolvedMin : 0;
        const max = Number.isFinite(resolvedMax) ? resolvedMax : min;

        const grid = document.createElement("div");
        grid.className = "heatmap-grid";
        grid.style.setProperty("--rows", rows);
        grid.style.setProperty("--cols", cols);

        displayValues.forEach((value) => {
          const cell = document.createElement("div");
          cell.className = "heatmap-cell";
          if (Number.isFinite(value)) {
            cell.textContent = value.toFixed(2);
            cell.style.backgroundColor = valueToColor(value, min, max);
            cell.style.color = valueToTextColor(value, min, max);
            cell.title = `${t("heatmap.tooltip.value")}${value}`;
          } else {
            cell.classList.add("is-empty");
            cell.textContent = "--";
            cell.title = t("heatmap.tooltip.missing");
          }
          grid.appendChild(cell);
        });

        heatmapContainer.appendChild(grid);
      }

      function updateLayoutOptions() {
        if (!layoutSelector) {
          return;
        }
        const entry = selectedDevice ? state.get(selectedDevice) : null;
        if (mirrorRowsToggle) {
          mirrorRowsToggle.disabled = true;
        }
        if (mirrorColsToggle) {
          mirrorColsToggle.disabled = true;
        }
        syncMirrorControlsFromState();
        const sensorCount =
          entry && Number.isInteger(entry.sensorCount) && entry.sensorCount > 0
            ? entry.sensorCount
            : null;
        const languageChanged = layoutOptionsCache.lang !== currentLanguage;
        const hasValidEntry = Boolean(entry) && sensorCount !== null;

        if (!hasValidEntry) {
          if (
            layoutOptionsCache.dn !== null ||
            layoutOptionsCache.sensorCount !== null ||
            languageChanged
          ) {
            layoutSelector.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "--";
            layoutSelector.appendChild(option);
          }
          layoutSelector.disabled = true;
          layoutSelector.value = "";
          selectedLayoutKey = null;
          mirrorRows = false;
          mirrorCols = false;
          if (mirrorRowsToggle) {
            mirrorRowsToggle.disabled = true;
            mirrorRowsToggle.checked = false;
          }
          if (mirrorColsToggle) {
            mirrorColsToggle.disabled = true;
            mirrorColsToggle.checked = false;
          }
          layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: currentLanguage };
          setHeatmapPlaceholder("heatmap.empty.no_device");
          return;
        }

        const pairs = computeFactorPairs(sensorCount);
        const optionKeys = pairs.map(([rows, cols]) => `${rows}x${cols}`);
        if (!optionKeys.length) {
          layoutSelector.innerHTML = "";
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "--";
          layoutSelector.appendChild(option);
          layoutSelector.disabled = true;
          selectedLayoutKey = null;
          layoutOptionsCache = { dn: entry.dn, sensorCount, options: [], selectedKey: null, lang: currentLanguage };
          if (mirrorRowsToggle) {
            mirrorRowsToggle.disabled = true;
            mirrorRowsToggle.checked = false;
          }
          if (mirrorColsToggle) {
            mirrorColsToggle.disabled = true;
            mirrorColsToggle.checked = false;
          }
          setHeatmapPlaceholder("heatmap.empty.no_layout");
          return;
        }

        const optionsChanged =
          layoutOptionsCache.dn !== entry.dn ||
          layoutOptionsCache.sensorCount !== sensorCount ||
          !arraysEqual(optionKeys, layoutOptionsCache.options) ||
          languageChanged;

        if (optionsChanged) {
          layoutSelector.innerHTML = "";
          pairs.forEach(([rows, cols]) => {
            const key = `${rows}x${cols}`;
            const option = document.createElement("option");
            option.value = key;
            option.textContent = `${rows} × ${cols}`;
            layoutSelector.appendChild(option);
          });
        }

        if (!selectedLayoutKey || !optionKeys.includes(selectedLayoutKey)) {
          selectedLayoutKey =
            layoutOptionsCache.selectedKey && optionKeys.includes(layoutOptionsCache.selectedKey)
              ? layoutOptionsCache.selectedKey
              : chooseDefaultLayout(pairs);
        }

        layoutSelector.value = selectedLayoutKey;
        layoutSelector.disabled = false;

        if (mirrorRowsToggle) {
          mirrorRowsToggle.disabled = false;
        }
        if (mirrorColsToggle) {
          mirrorColsToggle.disabled = false;
        }
        syncMirrorControlsFromState();

        layoutOptionsCache = {
          dn: entry.dn,
          sensorCount,
          options: optionKeys,
          selectedKey: selectedLayoutKey,
          lang: currentLanguage
        };
        updateHeatmap();
      }

      function updateDeviceOptions() {
        if (!deviceSelector) {
          return false;
        }
        const devices = Array.from(state.keys()).sort();
        const previousSelection = selectedDevice;
        const listChanged = !arraysEqual(devices, deviceOptionsCache.devices);
        const languageChanged = deviceOptionsCache.lang !== currentLanguage;

        if (!devices.length) {
          if (listChanged || languageChanged) {
            deviceSelector.innerHTML = "";
            const option = document.createElement("option");
            option.value = "";
            option.textContent = t("controls.waiting");
            deviceSelector.appendChild(option);
          }
          deviceSelector.disabled = true;
          deviceSelector.value = "";
          selectedDevice = null;
          deviceOptionsCache = { devices, selected: null, lang: currentLanguage };
          layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: null };
          return listChanged || languageChanged || previousSelection !== null;
        }

        if (listChanged || languageChanged) {
          deviceSelector.innerHTML = "";
          devices.forEach((dn) => {
            const option = document.createElement("option");
            option.value = dn;
            option.textContent = dn;
            deviceSelector.appendChild(option);
          });
        }

        if (!selectedDevice || !devices.includes(selectedDevice)) {
          selectedDevice = previousSelection && devices.includes(previousSelection)
            ? previousSelection
            : devices[0];
        }

        if (deviceSelector.value !== selectedDevice) {
          deviceSelector.value = selectedDevice;
        }
        deviceSelector.disabled = false;

        const selectionChanged = selectedDevice !== previousSelection;
        deviceOptionsCache = { devices, selected: selectedDevice, lang: currentLanguage };
        return listChanged || languageChanged || selectionChanged;
      }

      // --- Dashboard summary (active devices / total pressure) ---
      // --- 仪表盘概要：活跃设备与总压力 ---
      function updateSummary() {
        const now = Date.now();
        let active = 0;
        let total = 0;
        for (const entry of state.values()) {
          if (Number.isFinite(entry.pressureSum)) {
            total += entry.pressureSum;
          }
          if (entry.receivedAt && now - entry.receivedAt <= STALE_THRESHOLD_MS) {
            active += 1;
          }
        }
        if (activeDevicesLabel) {
          activeDevicesLabel.textContent = active;
        }
        if (totalPressureLabel) {
          totalPressureLabel.textContent = total.toFixed(2);
        }
      }

      function updateLastUpdateIndicator() {
        const latest = Array.from(state.values()).reduce(
          (max, entry) => Math.max(max, entry.receivedAt || 0),
          0
        );
        if (lastUpdateLabel) {
          lastUpdateLabel.textContent = latest ? new Date(latest).toLocaleString() : "--";
        }
      }

      function performRefresh() {
        pendingRefresh = false;
        lastRefreshTimestamp = Date.now();
        updateSummary();
        updateTable();
        const deviceChanged = updateDeviceOptions();
        if (deviceChanged || selectedDevice !== null) {
          updateLayoutOptions();
        }
        updateLastUpdateIndicator();
      }

      function refreshUI() {
        pendingRefresh = true;
        if (refreshTimerId !== null) {
          return;
        }
        const now = Date.now();
        const elapsed = now - lastRefreshTimestamp;
        const delay = Math.max(REFRESH_INTERVAL_MS - elapsed, 0);
        refreshTimerId = window.setTimeout(() => {
          refreshTimerId = null;
          if (!pendingRefresh) {
            return;
          }
          performRefresh();
        }, delay);
      }

      function updateTable() {
        const tbody = document.querySelector("#device-table tbody");
        const now = Date.now();
        const rows = Array.from(state.values()).sort((a, b) => {
          if (a.dn && b.dn && a.dn.localeCompare) {
            return a.dn.localeCompare(b.dn, undefined, { numeric: true, sensitivity: "base" });
          }
          if (a.dn < b.dn) return -1;
          if (a.dn > b.dn) return 1;
          return 0;
        });
        tbody.innerHTML = "";
        const stopLabel = t("table.actions.stop_tracking");
        for (const entry of rows) {
          const tr = document.createElement("tr");
          const isStale = !entry.receivedAt || now - entry.receivedAt > STALE_THRESHOLD_MS;
          if (isStale) {
            tr.classList.add("text-muted");
          }
          const pressureText = Number.isFinite(entry.pressureSum) ? entry.pressureSum.toFixed(2) : "--";
          tr.innerHTML = `
            <td><code>${entry.dn}</code></td>
            <td>${entry.sensorCount ?? "--"}</td>
            <td>${pressureText}</td>
            <td>${entry.frameTime ? new Date(entry.frameTime).toLocaleString() : "--"}</td>
            <td>${entry.receivedAt ? new Date(entry.receivedAt).toLocaleString() : "--"}</td>
            <td class="text-center">
              <button type="button" class="btn btn-sm btn-outline-danger remove-device" data-dn="${entry.dn}">${stopLabel}</button>
            </td>
          `;
          const removeButton = tr.querySelector(".remove-device");
          if (removeButton) {
            removeButton.addEventListener("click", (event) => {
              event.stopPropagation();
              removeDevice(entry.dn);
            });
            removeButton.setAttribute("title", stopLabel);
          }
          tbody.appendChild(tr);
        }
      }

      function removeDevice(dn) {
        if (!state.has(dn)) {
          return;
        }
        state.delete(dn);
        mirrorSettingsByDevice.delete(dn);
        if (selectedDevice === dn) {
          selectedDevice = null;
          layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: layoutOptionsCache.lang };
        }
        refreshUI();
      }

      function normalizeEntry(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const dn = entry.dn || "UNKNOWN";
        const payload = entry.payload || {};
        let pressureSum = null;
        let sensorCount = null;
        let frameTime = null;
        let pressureValues = [];
        if (payload && typeof payload === "object") {
          const rawPressures = Array.isArray(payload.p) ? payload.p : [];
          const numericPressures = rawPressures.map((value) => {
            const num = Number(value);
            return Number.isFinite(num) ? num : NaN;
          });
          const declaredCount = Number(payload.sn);
          if (Number.isInteger(declaredCount) && declaredCount > 0) {
            sensorCount = declaredCount;
          } else {
            sensorCount = numericPressures.length;
          }
          pressureValues = numericPressures.slice(0, sensorCount);
          while (pressureValues.length < sensorCount) {
            pressureValues.push(NaN);
          }
          pressureSum = pressureValues.reduce(
            (acc, value) => acc + (Number.isFinite(value) ? value : 0),
            0
          );
          if (payload.ts) {
            frameTime = payload.ts * 1000;
          }
        }
        const receivedAt = entry.received_at ? Date.parse(entry.received_at) : Date.now();
        return {
          dn,
          pressureSum,
          sensorCount,
          frameTime,
          receivedAt,
          pressureValues,
          raw: entry
        };
      }

      function applyEntry(entry, options = {}) {
        const normalized = normalizeEntry(entry);
        if (!normalized) return;
        state.set(normalized.dn, normalized);
        if (options.defer) {
          return;
        }
        refreshUI();
      }

      // Fetch periodic snapshots to guard against SSE hiccups.
      // 轮询获取快照，防止 SSE 偶发中断导致数据落后。
      async function fetchSnapshot() {
        try {
          const resp = await fetch(SNAPSHOT_ENDPOINT);
          const data = await resp.json();
          if (Array.isArray(data.data)) {
            data.data.forEach((item) => applyEntry(item, { defer: true }));
            refreshUI();
          }
          setStatusIndicator("snapshot_ok");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-secondary", "bg-danger");
            statusIndicator.classList.add("bg-success");
          }
        } catch (err) {
          setStatusIndicator("snapshot_error");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-secondary", "bg-success");
            statusIndicator.classList.add("bg-danger");
          }
          console.error(t("console.snapshot_fetch_failed"), err);
        }
      }

      // Subscribe to bridge SSE stream for near real-time updates.
      // 订阅桥接 SSE 流，实现准实时更新。
      function subscribeStream() {
        cleanupEventSource();
        clearStreamReconnectTimer();
        const source = new EventSource(STREAM_ENDPOINT);
        currentEventSource = source;
        setStatusIndicator("connecting");
        if (statusIndicator) {
          statusIndicator.classList.remove("bg-success", "bg-danger", "bg-warning");
          statusIndicator.classList.add("bg-secondary");
        }
        source.addEventListener("snapshot", (event) => {
          try {
            const payload = JSON.parse(event.data);
            if (Array.isArray(payload.data)) {
              payload.data.forEach((item) => applyEntry(item, { defer: true }));
              refreshUI();
            }
          } catch (err) {
            console.error(t("console.snapshot_event_error"), err);
          }
        });
        source.addEventListener("update", (event) => {
          try {
            const payload = JSON.parse(event.data);
            applyEntry(payload);
          } catch (err) {
            console.error(t("console.update_event_error"), err);
          }
        });
        source.addEventListener("error", () => {
          setStatusIndicator("stream_error");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-success");
            statusIndicator.classList.add("bg-warning");
          }
          cleanupEventSource();
          const shouldFetchSnapshot = streamReconnectTimerId === null;
          scheduleStreamReconnect();
          if (shouldFetchSnapshot) {
            fetchSnapshot();
          }
        });
        source.onopen = () => {
          clearStreamReconnectTimer();
          streamReconnectAttempts = 0;
          setStatusIndicator("stream_ok");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-secondary", "bg-danger", "bg-warning");
            statusIndicator.classList.add("bg-success");
          }
        };
      }

      applyLanguage();
      performRefresh();
      fetchSnapshot();
      if (snapshotPollTimerId === null) {
        snapshotPollTimerId = window.setInterval(fetchSnapshot, SNAPSHOT_POLL_INTERVAL_MS);
      }
      window.addEventListener("beforeunload", () => {
        cleanupEventSource();
        clearStreamReconnectTimer();
        if (snapshotPollTimerId !== null) {
          window.clearInterval(snapshotPollTimerId);
          snapshotPollTimerId = null;
        }
      });
      subscribeStream();
    </script>
  </body>
</html>
