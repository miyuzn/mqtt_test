<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>リアルタイム圧力モニター</title>

    <!-- 去掉 integrity / crossorigin -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    />

    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body>
    <!-- Main dashboard wrapper: controls header + heatmap + stats -->
    <!-- 主仪表盘容器：包含头部、热力图与统计信息 -->
    <div class="container py-4">
      <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
        <div>
          <h1 class="h3 mb-1" data-i18n="header.title">实时压力监控面板</h1>
          <p class="text-muted mb-0">
            <span data-i18n="header.data_source">数据来源：</span><code>{{ bridge_api_base }}</code>
          </p>
        </div>
        <div class="text-md-end">
          <div class="btn-group btn-group-sm language-switcher mb-2" role="group" id="language-switcher">
            <button type="button" class="btn btn-outline-secondary" data-lang="ja">日本語</button>
            <button type="button" class="btn btn-outline-secondary" data-lang="en">English</button>
            <button type="button" class="btn btn-outline-secondary" data-lang="zh">中文</button>
          </div>
          <div class="badge bg-secondary d-block" id="status-indicator" data-i18n="status.connecting">连接中...</div>
          <div class="small text-muted" id="last-update">--</div>
        </div>
      </div>
  
      <!-- Heatmap + detail cards region -->
      <!-- 热力图与详情卡片区域 -->
      <div class="row g-4">
        <div class="col-lg-8">
          <div class="card shadow-sm h-100">
            <div class="card-body">
              <div class="d-flex flex-column flex-xl-row align-items-xl-center justify-content-between gap-3 mb-3">
                <h2 class="h5 mb-0" data-i18n="heatmap.heading">压力热力图</h2>
                <div class="form-check form-switch dual-mode-switch mb-0">
                  <input class="form-check-input" type="checkbox" id="dual-mode-toggle" />
                  <label class="form-check-label" for="dual-mode-toggle" data-i18n="controls.dual_mode">双设备模式</label>
                </div>
              </div>
              <div class="pressure-range-card mb-3">
                <div class="row gy-2 gx-2 align-items-center">
                  <div class="col-12">
                    <div class="fw-semibold text-secondary" data-i18n="controls.range">压力范围</div>
                  </div>
                  <div class="col-12 col-sm-6 col-md-4 col-xl-3">
                    <label class="visually-hidden" for="pressure-min" data-i18n="inputs.lower_label">压力下限</label>
                    <div class="input-group">
                      <span class="input-group-text" data-i18n="inputs.lower_label">下限</span>
                      <input
                        type="number"
                        class="form-control"
                        id="pressure-min"
                        placeholder="下限"
                        data-i18n-placeholder="inputs.placeholder.lower"
                        step="any"
                      />
                    </div>
                  </div>
                  <div class="col-12 col-sm-6 col-md-4 col-xl-3">
                    <label class="visually-hidden" for="pressure-max" data-i18n="inputs.upper_label">压力上限</label>
                    <div class="input-group">
                      <span class="input-group-text" data-i18n="inputs.upper_label">上限</span>
                      <input
                        type="number"
                        class="form-control"
                        id="pressure-max"
                        placeholder="上限"
                        data-i18n-placeholder="inputs.placeholder.upper"
                        step="any"
                      />
                    </div>
                  </div>
                  <div class="col-12 col-sm-auto">
                    <button class="btn btn-outline-secondary w-100 w-sm-auto" type="button" id="reset-range" data-i18n="actions.reset">
                      重置
                    </button>
                  </div>
                </div>
              </div>
              <div class="dual-heatmap-grid">
                <section class="heatmap-panel" aria-labelledby="panel-primary-label" id="panel-primary">
                  <div class="heatmap-panel-header">
                    <h3 class="h6 mb-0" id="panel-primary-label" data-i18n="controls.primary_panel">设备 A</h3>
                  </div>
                  <div class="heatmap-panel-controls">
                    <div class="input-group mb-2">
                      <span class="input-group-text" data-i18n="controls.device_primary">设备 A</span>
                      <select class="form-select" id="device-selector-primary" disabled>
                        <option value="" data-i18n="controls.waiting">等待数据...</option>
                      </select>
                    </div>
                    <div class="input-group mb-2">
                      <span class="input-group-text" data-i18n="controls.layout">布局</span>
                      <select class="form-select" id="layout-selector-primary" disabled>
                        <option value="">--</option>
                      </select>
                    </div>
                    <div class="mirror-toggle-group d-flex flex-wrap align-items-center gap-3">
                      <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="mirror-rows-primary" />
                        <label class="form-check-label" for="mirror-rows-primary" data-i18n="controls.mirror_rows">行镜像</label>
                      </div>
                      <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="mirror-cols-primary" />
                        <label class="form-check-label" for="mirror-cols-primary" data-i18n="controls.mirror_cols">列镜像</label>
                      </div>
                    </div>
                  </div>
                  <div class="heatmap-wrapper" id="heatmap-container-primary">
                    <div class="heatmap-placeholder" data-i18n="heatmap.empty.waiting">等待数据...</div>
                  </div>
                </section>
                <section class="heatmap-panel d-none" aria-labelledby="panel-secondary-label" id="panel-secondary">
                  <div class="heatmap-panel-header">
                    <h3 class="h6 mb-0" id="panel-secondary-label" data-i18n="controls.secondary_panel">设备 B</h3>
                  </div>
                  <div class="heatmap-panel-controls">
                    <div class="input-group mb-2">
                      <span class="input-group-text" data-i18n="controls.device_secondary">设备 B</span>
                      <select class="form-select" id="device-selector-secondary" disabled>
                        <option value="" data-i18n="controls.waiting">等待数据...</option>
                      </select>
                    </div>
                    <div class="input-group mb-2">
                      <span class="input-group-text" data-i18n="controls.layout">布局</span>
                      <select class="form-select" id="layout-selector-secondary" disabled>
                        <option value="">--</option>
                      </select>
                    </div>
                    <div class="mirror-toggle-group d-flex flex-wrap align-items-center gap-3">
                      <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="mirror-rows-secondary" />
                        <label class="form-check-label" for="mirror-rows-secondary" data-i18n="controls.mirror_rows">行镜像</label>
                      </div>
                      <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="mirror-cols-secondary" />
                        <label class="form-check-label" for="mirror-cols-secondary" data-i18n="controls.mirror_cols">列镜像</label>
                      </div>
                    </div>
                  </div>
                  <div class="heatmap-wrapper" id="heatmap-container-secondary">
                    <div class="heatmap-placeholder" data-i18n="heatmap.empty.no_device">选择设备以查看压力热力图</div>
                  </div>
                </section>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-4">
          <div class="card shadow-sm h-100">
            <div class="card-body">
              <h2 class="h5 mb-3" data-i18n="overview.title">当前概览</h2>
              <div class="overview-metric-grid">
                <div>
                  <div class="fw-semibold" data-i18n="overview.active_devices">活跃设备</div>
                  <div class="display-6" id="active-devices">0</div>
                </div>
                <div class="overview-sensors">
                  <div class="overview-sensor-block">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                      <div class="fw-semibold" data-i18n="overview.gyro">陀螺仪 (°/s)</div>
                    </div>
                    <div class="sensor-vector" id="gyro-summary">
                      <div class="axis-value">
                        <span>X</span>
                        <strong id="gyro-x">--</strong>
                      </div>
                      <div class="axis-value">
                        <span>Y</span>
                        <strong id="gyro-y">--</strong>
                      </div>
                      <div class="axis-value">
                        <span>Z</span>
                        <strong id="gyro-z">--</strong>
                      </div>
                    </div>
                  </div>
                  <div class="overview-sensor-block">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                      <div class="fw-semibold" data-i18n="overview.acc">加速度 (m/s²)</div>
                    </div>
                    <div class="sensor-vector" id="acc-summary">
                      <div class="axis-value">
                        <span>X</span>
                        <strong id="acc-x">--</strong>
                      </div>
                      <div class="axis-value">
                        <span>Y</span>
                        <strong id="acc-y">--</strong>
                      </div>
                      <div class="axis-value">
                        <span>Z</span>
                        <strong id="acc-z">--</strong>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="text-muted small" id="sensor-source">
                  <span data-i18n="overview.source_label">数据来源：</span>
                  <span id="sensor-source-dn">--</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Device table showing latest snapshot per DN -->
      <!-- 设备表：展示每个 DN 的最新快照 -->
      <div class="card shadow-sm mt-4">
        <div class="card-body">
          <h2 class="h5 mb-3" data-i18n="table.title">设备详情</h2>
          <div class="table-responsive" style="max-height: 360px;">
            <table class="table table-striped align-middle" id="device-table">
              <thead class="table-light sticky-top">
                <tr>
                  <th scope="col" data-i18n="table.headers.dn">DN</th>
                  <th scope="col" data-i18n="table.headers.count">压力传感器数</th>
                  <th scope="col" data-i18n="table.headers.frame_time">最新帧时间</th>
                  <th scope="col" data-i18n="table.headers.receive_time">接收时间</th>
                  <th scope="col" class="text-center" data-i18n="table.headers.actions">操作</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <!-- Front-end logic: state management, i18n, SSE subscriptions -->
    <!-- 前端逻辑：状态管理、多语言与 SSE 订阅 -->
    <script>
      // Front-end state setup & DOM references. Keeps real-time UI consistent.
      // 前端状态与 DOM 引用定义，用于维持实时界面一致性。
      const SNAPSHOT_ENDPOINT = "{{ url_for('proxy_latest') }}";
      const STREAM_ENDPOINT = "{{ url_for('proxy_stream') }}";

      const state = new Map();
      const mirrorSettingsByDevice = new Map();
      const STALE_THRESHOLD_MS = 30 * 1000;
      const panelContexts = ["primary", "secondary"].map((key) => ({
        key,
        panelElement: document.getElementById(`panel-${key}`),
        deviceSelector: document.getElementById(`device-selector-${key}`),
        layoutSelector: document.getElementById(`layout-selector-${key}`),
        heatmapContainer: document.getElementById(`heatmap-container-${key}`),
        mirrorRowsToggle: document.getElementById(`mirror-rows-${key}`),
        mirrorColsToggle: document.getElementById(`mirror-cols-${key}`),
        selectedDevice: null,
        selectedLayoutKey: null,
        mirrorRows: false,
        mirrorCols: false,
        deviceOptionsCache: { devices: [], selected: null, lang: null },
        layoutOptionsCache: { dn: null, sensorCount: null, options: [], selectedKey: null, lang: null }
      }));
      const primaryPanel = panelContexts[0];
      const secondaryPanel = panelContexts[1];
      const dualModeToggle = document.getElementById("dual-mode-toggle");
      let dualModeEnabled = localStorage.getItem("dualModeEnabled") === "1";
      const pressureMinInput = document.getElementById("pressure-min");
      const pressureMaxInput = document.getElementById("pressure-max");
      const resetRangeButton = document.getElementById("reset-range");
      const statusIndicator = document.getElementById("status-indicator");
      const activeDevicesLabel = document.getElementById("active-devices");
      const lastUpdateLabel = document.getElementById("last-update");
      const gyroElements = {
        x: document.getElementById("gyro-x"),
        y: document.getElementById("gyro-y"),
        z: document.getElementById("gyro-z")
      };
      const accElements = {
        x: document.getElementById("acc-x"),
        y: document.getElementById("acc-y"),
        z: document.getElementById("acc-z")
      };
      const sensorSourceLabel = document.getElementById("sensor-source-dn");
      const languageButtons = document.querySelectorAll("#language-switcher [data-lang]");
      let customRangeMin = null;
      let customRangeMax = null;
      const REFRESH_INTERVAL_MS = 250;
      const SNAPSHOT_POLL_INTERVAL_MS = 30000;
      const STREAM_RECONNECT_BASE_DELAY_MS = 2000;
      const STREAM_RECONNECT_MAX_DELAY_MS = 15000;
      let pendingRefresh = false;
      let refreshTimerId = null;
      let lastRefreshTimestamp = 0;
      let snapshotPollTimerId = null;
      let currentEventSource = null;
      let streamReconnectTimerId = null;
      let streamReconnectAttempts = 0;

      // --- Stream lifecycle helpers: manage SSE backoff/retry flow ---
      // --- 流式连接辅助：管理 SSE 回退与重连流程 ---
      function clearStreamReconnectTimer() {
        // Skip cleanup when no reconnect delay is scheduled / 若未安排重连则无需清理
        if (streamReconnectTimerId !== null) {
          // Cancel pending reconnect to avoid duplicated timers / 取消等待中的重连以避免重复定时器
          window.clearTimeout(streamReconnectTimerId);
          streamReconnectTimerId = null;
        }
      }

      function scheduleStreamReconnect() {
        // Avoid stacking multiple reconnect timers / 避免堆叠多个重连定时器
        if (streamReconnectTimerId !== null) {
          return;
        }
        // Use exponential backoff but clamp to max delay / 采用指数退避并限制最大延迟
        const delay = Math.min(
          STREAM_RECONNECT_BASE_DELAY_MS * Math.max(1, Math.pow(2, streamReconnectAttempts)),
          STREAM_RECONNECT_MAX_DELAY_MS
        );
        // Schedule the retry and track attempt count / 设定重连任务并跟踪尝试次数
        streamReconnectTimerId = window.setTimeout(() => {
          streamReconnectTimerId = null;
          streamReconnectAttempts += 1;
          subscribeStream();
        }, delay);
      }

      function cleanupEventSource() {
        // Close the EventSource gently to release network resources / 温和关闭 EventSource 以释放网络资源
        if (currentEventSource) {
          currentEventSource.close();
          currentEventSource = null;
        }
      }

      // Compare simple arrays for option caching, avoiding unnecessary DOM churn.
      // 比较简单数组，若相同则避免重复刷新 DOM。
      function arraysEqual(left, right) {
        // Quick length check before comparing individual entries / 在逐项比较前先快速比长度
        if (left.length !== right.length) {
          return false;
        }
        // Compare element by element to detect any difference / 按元素比较以捕捉差异
        for (let i = 0; i < left.length; i += 1) {
          if (left[i] !== right[i]) {
            return false;
          }
        }
        // All entries match, arrays are effectively identical / 所有元素一致，视为相同数组
        return true;
      }

      function panelIsActive(panel) {
        return panel.key !== "secondary" || dualModeEnabled;
      }

      function applyDualModeState() {
        if (dualModeToggle) {
          dualModeToggle.checked = dualModeEnabled;
        }
        if (secondaryPanel.panelElement) {
          secondaryPanel.panelElement.classList.toggle("d-none", !dualModeEnabled);
        }
      }

      function setDualMode(enabled) {
        dualModeEnabled = enabled;
        localStorage.setItem("dualModeEnabled", enabled ? "1" : "0");
        applyDualModeState();
        updateDeviceOptions();
        panelContexts.forEach((panel) => updateLayoutOptionsForPanel(panel));
        updateAllHeatmaps();
        updateOverviewSensors();
      }

      const COLOR_GREEN = [46, 204, 113];
      const COLOR_YELLOW = [241, 196, 15];
      const COLOR_ORANGE = [243, 156, 18];
      const COLOR_RED = [231, 76, 60];

      const GRADIENT_STOPS = [
        { stop: 0, color: COLOR_GREEN },
        { stop: 0.33, color: COLOR_YELLOW },
        { stop: 0.66, color: COLOR_ORANGE },
        { stop: 1, color: COLOR_RED }
      ];

      const LANGUAGE_META = {
        zh: { locale: "zh-CN" },
        ja: { locale: "ja-JP" },
        en: { locale: "en" }
      };

      const TRANSLATIONS = {
        zh: {
          "page.title": "实时压力监控面板",
          "header.title": "实时压力监控面板",
          "header.data_source": "数据来源：",
          "status.connecting": "连接中...",
          "status.snapshot_ok": "已连接",
          "status.snapshot_error": "桥接不可用",
          "status.stream_error": "实时连接中断",
          "status.stream_ok": "实时连接已建立",
          "heatmap.heading": "压力热力图",
          "controls.device": "设备",
          "controls.primary_panel": "设备 A",
          "controls.secondary_panel": "设备 B",
          "controls.device_primary": "设备 A",
          "controls.device_secondary": "设备 B",
          "controls.dual_mode": "双设备模式",
          "controls.layout": "布局",
          "controls.mirror_rows": "行镜像",
          "controls.mirror_cols": "列镜像",
          "controls.range": "压力范围",
          "controls.waiting": "等待数据...",
          "inputs.lower_label": "下限",
          "inputs.upper_label": "上限",
          "inputs.placeholder.lower": "下限",
          "inputs.placeholder.upper": "上限",
          "actions.reset": "重置",
          "overview.title": "当前概览",
          "overview.active_devices": "活跃设备",
          "overview.total_pressure": "总压力",
          "overview.gyro": "陀螺仪 (°/s)",
          "overview.acc": "加速度 (m/s²)",
          "overview.source_label": "数据来源：",
          "table.title": "设备详情",
          "table.headers.dn": "DN",
          "table.headers.count": "压力传感器数",
          "table.headers.sum": "压力总和",
          "table.headers.frame_time": "最新帧时间",
          "table.headers.receive_time": "接收时间",
          "table.headers.actions": "操作",
          "table.actions.stop_tracking": "停止追踪",
          "heatmap.empty.no_device": "选择设备以查看压力热力图",
          "heatmap.empty.no_layout": "请选择布局组合",
          "heatmap.empty.waiting": "等待设备数据更新...",
          "heatmap.empty.dual_disabled": "开启双设备模式以查看第二设备",
          "heatmap.tooltip.value": "压力值：",
          "heatmap.tooltip.missing": "缺少压力数据",
          "console.snapshot_fetch_failed": "无法获取数据",
          "console.snapshot_event_error": "解析快照事件失败",
          "console.update_event_error": "解析更新事件失败"
        },
        ja: {
          "page.title": "リアルタイム圧力モニター",
          "header.title": "リアルタイム圧力モニター",
          "header.data_source": "データソース：",
          "status.connecting": "接続中...",
          "status.snapshot_ok": "スナップショットを取得",
          "status.snapshot_error": "ブリッジに接続できません",
          "status.stream_error": "リアルタイム接続が中断しました",
          "status.stream_ok": "リアルタイム接続が確立されました",
          "heatmap.heading": "圧力ヒートマップ",
          "controls.device": "デバイス",
          "controls.primary_panel": "デバイスA",
          "controls.secondary_panel": "デバイスB",
          "controls.device_primary": "デバイスA",
          "controls.device_secondary": "デバイスB",
          "controls.dual_mode": "デュアル表示",
          "controls.layout": "レイアウト",
          "controls.mirror_rows": "行を反転",
          "controls.mirror_cols": "列を反転",
          "controls.range": "圧力範囲",
          "controls.waiting": "データ待機中...",
          "inputs.lower_label": "下限",
          "inputs.upper_label": "上限",
          "inputs.placeholder.lower": "下限",
          "inputs.placeholder.upper": "上限",
          "actions.reset": "リセット",
          "overview.title": "概要",
          "overview.active_devices": "アクティブデバイス",
          "overview.total_pressure": "総圧力",
          "overview.gyro": "ジャイロ (°/s)",
          "overview.acc": "加速度 (m/s²)",
          "overview.source_label": "データ元：",
          "table.title": "デバイス詳細",
          "table.headers.dn": "DN",
          "table.headers.count": "センサー数",
          "table.headers.sum": "圧力合計",
          "table.headers.frame_time": "最新フレーム時刻",
          "table.headers.receive_time": "受信時刻",
          "table.headers.actions": "操作",
          "table.actions.stop_tracking": "監視を停止",
          "heatmap.empty.no_device": "デバイスを選択してヒートマップを表示",
          "heatmap.empty.no_layout": "レイアウトを選択してください",
          "heatmap.empty.waiting": "デバイスデータの更新を待機中...",
          "heatmap.empty.dual_disabled": "デュアル表示を有効にすると表示されます",
          "heatmap.tooltip.value": "圧力値：",
          "heatmap.tooltip.missing": "圧力データなし",
          "console.snapshot_fetch_failed": "データを取得できませんでした",
          "console.snapshot_event_error": "スナップショットイベントの解析に失敗しました",
          "console.update_event_error": "アップデートイベントの解析に失敗しました"
        },
        en: {
          "page.title": "Real-Time Pressure Dashboard",
          "header.title": "Real-Time Pressure Dashboard",
          "header.data_source": "Data source: ",
          "status.connecting": "Connecting...",
          "status.snapshot_ok": "Snapshot loaded",
          "status.snapshot_error": "Bridge unavailable",
          "status.stream_error": "Realtime feed interrupted",
          "status.stream_ok": "Realtime feed active",
          "heatmap.heading": "Pressure Heatmap",
          "controls.device": "Device",
          "controls.primary_panel": "Device A",
          "controls.secondary_panel": "Device B",
          "controls.device_primary": "Device A",
          "controls.device_secondary": "Device B",
          "controls.dual_mode": "Dual mode",
          "controls.layout": "Layout",
          "controls.mirror_rows": "Mirror rows",
          "controls.mirror_cols": "Mirror columns",
          "controls.range": "Pressure range",
          "controls.waiting": "Waiting for data...",
          "inputs.lower_label": "Min",
          "inputs.upper_label": "Max",
          "inputs.placeholder.lower": "Min",
          "inputs.placeholder.upper": "Max",
          "actions.reset": "Reset",
          "overview.title": "Overview",
          "overview.active_devices": "Active devices",
          "overview.total_pressure": "Total pressure",
          "overview.gyro": "Gyroscope (°/s)",
          "overview.acc": "Acceleration (m/s²)",
          "overview.source_label": "Data source:",
          "table.title": "Device Details",
          "table.headers.dn": "DN",
          "table.headers.count": "Sensor count",
          "table.headers.sum": "Pressure total",
          "table.headers.frame_time": "Latest frame time",
          "table.headers.receive_time": "Received at",
          "table.headers.actions": "Actions",
          "table.actions.stop_tracking": "Stop tracking",
          "heatmap.empty.no_device": "Select a device to view the heatmap",
          "heatmap.empty.no_layout": "Choose a layout",
          "heatmap.empty.waiting": "Waiting for device data...",
          "heatmap.empty.dual_disabled": "Enable dual mode to visualize the second device",
          "heatmap.tooltip.value": "Pressure: ",
          "heatmap.tooltip.missing": "No pressure data",
          "console.snapshot_fetch_failed": "Failed to fetch data",
          "console.snapshot_event_error": "Failed to parse snapshot event",
          "console.update_event_error": "Failed to parse update event"
        }
      };
      let currentLanguage = localStorage.getItem("uiLanguage") || "ja";
      if (!Object.prototype.hasOwnProperty.call(TRANSLATIONS, currentLanguage)) {
        currentLanguage = "ja";
      }
      let currentStatusKey = "connecting";

      // --- Internationalization helpers: resolve localized strings on demand ---
      // --- 多语言辅助：按需解析文案 ---
      function t(key) {
        // Resolve translation pack based on current language / 根据当前语言选择翻译包
        const pack = TRANSLATIONS[currentLanguage] || TRANSLATIONS.ja;
        if (Object.prototype.hasOwnProperty.call(pack, key)) {
          return pack[key];
        }
        // Fallback to Japanese pack or raw key if missing / 若缺失则回退到日文或直接返回 key
        return TRANSLATIONS.ja[key] ?? key;
      }

      function updateStatusIndicatorText() {
        // Indicator may not exist in minimal layouts / 精简布局可能没有状态指示器
        if (!statusIndicator) {
          return;
        }
        // Refresh the DOM label using localized text / 使用本地化文本刷新指示器
        statusIndicator.textContent = t(`status.${currentStatusKey}`);
      }

      function setStatusIndicator(stateKey) {
        // Persist key to drive follow-up updates / 保存状态键以驱动后续刷新
        currentStatusKey = stateKey;
        updateStatusIndicatorText();
      }

      function updateLanguageSwitcherState() {
        // Toggle active button styling to reflect selection / 切换按钮样式以反映当前语言
        languageButtons.forEach((button) => {
          const isActive = button.dataset.lang === currentLanguage;
          button.classList.toggle("btn-primary", isActive);
          button.classList.toggle("btn-outline-secondary", !isActive);
          button.setAttribute("aria-pressed", String(isActive));
        });
      }

      function applyLanguage() {
        // Update document metadata for assistive tech / 更新文档语言信息以便辅助工具
        const locale = LANGUAGE_META[currentLanguage]?.locale || "ja-JP";
        document.documentElement.lang = locale;
        document.title = t("page.title");
        // Replace text content for all data-i18n nodes / 为所有 data-i18n 节点替换文本
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.dataset.i18n;
          if (!key) return;
          const translation = t(key);
          if (translation !== undefined) {
            el.textContent = translation;
          }
        });
        // Sync placeholder attributes since they don't use textContent / 同步 placeholder 属性因为它们不走 textContent
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.dataset.i18nPlaceholder;
          if (!key) return;
          const translation = t(key);
          if (translation !== undefined) {
            el.setAttribute("placeholder", translation);
          }
        });
        // Dependent UI (status, buttons, inputs) also need refresh / 依赖语言的状态、按钮与输入框同样需要刷新
        updateStatusIndicatorText();
        updateLanguageSwitcherState();
        updateRangePlaceholders(null, null);
      }

      function setLanguage(lang) {
        // Ignore unknown locales to avoid corrupting storage / 忽略未知语言以免破坏存储
        if (!Object.prototype.hasOwnProperty.call(TRANSLATIONS, lang)) {
          return;
        }
        // Persist selection and re-render UI / 记录选择并重新渲染界面
        currentLanguage = lang;
        localStorage.setItem("uiLanguage", lang);
        applyLanguage();
        refreshUI();
      }

      languageButtons.forEach((button) => {
        button.addEventListener("click", () => {
          setLanguage(button.dataset.lang);
        });
      });

      if (dualModeToggle) {
        dualModeToggle.checked = dualModeEnabled;
        dualModeToggle.addEventListener("change", (event) => {
          setDualMode(Boolean(event.target.checked));
        });
      }
      applyDualModeState();

      panelContexts.forEach((panel) => {
        if (panel.deviceSelector) {
          panel.deviceSelector.addEventListener("change", (event) => {
            panel.selectedDevice = event.target.value || null;
            panel.deviceOptionsCache.selected = panel.selectedDevice;
            syncPanelMirrorControls(panel);
            updateLayoutOptionsForPanel(panel);
            updateOverviewSensors();
            updateAllHeatmaps();
          });
        }
        if (panel.layoutSelector) {
          panel.layoutSelector.addEventListener("change", (event) => {
            panel.selectedLayoutKey = event.target.value || null;
            panel.layoutOptionsCache.selectedKey = panel.selectedLayoutKey;
            updateAllHeatmaps();
          });
        }
        if (panel.mirrorRowsToggle) {
          panel.mirrorRowsToggle.addEventListener("change", (event) => {
            panel.mirrorRows = Boolean(event.target.checked);
            persistMirrorSettings(panel);
            updateAllHeatmaps();
          });
        }
        if (panel.mirrorColsToggle) {
          panel.mirrorColsToggle.addEventListener("change", (event) => {
            panel.mirrorCols = Boolean(event.target.checked);
            persistMirrorSettings(panel);
            updateAllHeatmaps();
          });
        }
      });

      if (pressureMinInput && pressureMaxInput) {
        ["input", "change"].forEach((eventName) => {
          pressureMinInput.addEventListener(eventName, handleCustomRangeChange);
          pressureMaxInput.addEventListener(eventName, handleCustomRangeChange);
        });
      }

      if (resetRangeButton) {
        resetRangeButton.addEventListener("click", () => {
          if (pressureMinInput) {
            pressureMinInput.value = "";
            pressureMinInput.classList.remove("is-invalid");
          }
          if (pressureMaxInput) {
            pressureMaxInput.value = "";
            pressureMaxInput.classList.remove("is-invalid");
          }
          customRangeMin = null;
          customRangeMax = null;
          updateAllHeatmaps();
        });
      }

      // --- Heatmap layout utilities: derive possible row/col pairs ---
      // --- 热力图布局工具：根据传感器数量推导行列组合 ---
      function computeFactorPairs(sn) {
        // Reject invalid sensor counts before factoring / 先排除无效的传感器数量
        if (!Number.isInteger(sn) || sn <= 0) {
          return [];
        }
        const basePairs = [];
        const limit = Math.floor(Math.sqrt(sn));
        // Enumerate divisors up to sqrt to gather row/column pairs / 遍历平方根范围内的因子以获取行列组合
        for (let i = 1; i <= limit; i += 1) {
          if (sn % i === 0) {
            basePairs.push([i, sn / i]);
          }
        }
        const pairs = [];
        // Include mirrored pairs so users can swap rows/cols / 包含镜像组合便于用户交换行列
        basePairs.forEach(([rows, cols]) => {
          pairs.push([rows, cols]);
          if (rows !== cols) {
            pairs.push([cols, rows]);
          }
        });
        // Prefer near-square layouts, then smaller sizes / 优先接近方阵的布局，其次按尺寸排序
        pairs.sort((a, b) => {
          const diffA = Math.abs(a[0] - a[1]);
          const diffB = Math.abs(b[0] - b[1]);
          if (diffA !== diffB) return diffA - diffB;
          if (a[0] !== b[0]) return a[0] - b[0];
          return a[1] - b[1];
        });
        return pairs;
      }

      function chooseDefaultLayout(pairs) {
        // Use first sorted candidate as default / 使用排序后的首个候选作为默认布局
        if (!pairs.length) {
          return null;
        }
        return `${pairs[0][0]}x${pairs[0][1]}`;
      }

      function parseLayoutKey(key) {
        // Layout keys look like \"8x16\"; split and coerce / 布局键形如 \"8x16\"，需拆分并转数字
        if (!key) {
          return null;
        }
        const [rows, cols] = key.split("x").map((value) => Number(value));
        if (!Number.isInteger(rows) || !Number.isInteger(cols)) {
          return null;
        }
        return [rows, cols];
      }

      function handleCustomRangeChange() {
        // Without inputs there's nothing to validate / 若缺少输入元素则无需校验
        if (!pressureMinInput || !pressureMaxInput) {
          return;
        }
        // Pull raw strings once for consistent handling / 读取原始字符串以便统一处理
        const rawMin = pressureMinInput.value.trim();
        const rawMax = pressureMaxInput.value.trim();
        const hasMin = rawMin !== "";
        const hasMax = rawMax !== "";
        const minValue = Number(rawMin);
        const maxValue = Number(rawMax);
        const minValid = !hasMin || Number.isFinite(minValue);
        const maxValid = !hasMax || Number.isFinite(maxValue);

        pressureMinInput.classList.remove("is-invalid");
        pressureMaxInput.classList.remove("is-invalid");

        // Reject invalid numeric input and reset custom overrides / 遇到非法数字时重置自定义范围
        if (!minValid || !maxValid) {
          if (!minValid) {
            pressureMinInput.classList.add("is-invalid");
          }
          if (!maxValid) {
            pressureMaxInput.classList.add("is-invalid");
          }
          customRangeMin = null;
          customRangeMax = null;
          updateAllHeatmaps();
          return;
        }

        if (hasMin && hasMax) {
          // Only accept range when min < max / 仅在最小值小于最大值时接受
          if (minValue < maxValue) {
            customRangeMin = minValue;
            customRangeMax = maxValue;
          } else {
            pressureMinInput.classList.add("is-invalid");
            pressureMaxInput.classList.add("is-invalid");
            customRangeMin = null;
            customRangeMax = null;
            updateAllHeatmaps();
            return;
          }
        } else {
          // Missing either bound means we fall back to auto range / 缺少任一边界则回退到自动范围
          customRangeMin = null;
          customRangeMax = null;
        }

        updateAllHeatmaps();
      }

      function updateRangePlaceholders(dataMin, dataMax) {
        // Show current data-derived defaults, else language-specific placeholder / 优先展示数据推导的默认值，否则使用多语言占位符
        if (pressureMinInput) {
          if (Number.isFinite(dataMin)) {
            pressureMinInput.placeholder = dataMin;
          } else {
            pressureMinInput.placeholder = t("inputs.placeholder.lower");
          }
        }
        if (pressureMaxInput) {
          if (Number.isFinite(dataMax)) {
            pressureMaxInput.placeholder = dataMax;
          } else {
            pressureMaxInput.placeholder = t("inputs.placeholder.upper");
          }
        }
      }

      function resolveEffectiveRange(dataMin, dataMax) {
        // User-defined bounds win when valid / 若用户自定义范围有效则使用之
        if (
          Number.isFinite(customRangeMin) &&
          Number.isFinite(customRangeMax) &&
          customRangeMin < customRangeMax
        ) {
          return { min: customRangeMin, max: customRangeMax };
        }
        // Otherwise fall back to data-driven min/max when available / 否则回退到数据驱动的上下限
        if (Number.isFinite(dataMin) && Number.isFinite(dataMax)) {
          return { min: dataMin, max: dataMax };
        }
        return { min: 0, max: 0 };
      }

      function toRgbString(color) {
        // Convert [r,g,b] tuple into CSS color string / 将 [r,g,b] 数组转换成 CSS 颜色字符串
        return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
      }

      function interpolateGradient(stops, ratio) {
        // Clamp ratio to [0,1] before interpolation / 插值前先将比值限制在 [0,1]
        const clamped = Math.min(1, Math.max(0, ratio));
        for (let i = 1; i < stops.length; i += 1) {
          if (clamped <= stops[i].stop) {
            const prev = stops[i - 1];
            const next = stops[i];
            const span = next.stop - prev.stop || 1;
            // Interpolate each color channel independently / 对每个颜色通道分别进行插值
            const localT = span === 0 ? 0 : (clamped - prev.stop) / span;
            const r = Math.round(prev.color[0] + (next.color[0] - prev.color[0]) * localT);
            const g = Math.round(prev.color[1] + (next.color[1] - prev.color[1]) * localT);
            const b = Math.round(prev.color[2] + (next.color[2] - prev.color[2]) * localT);
            return `rgb(${r}, ${g}, ${b})`;
          }
        }
        // If ratio beyond last stop, stick to final color / 若超出最后节点则直接返回末尾颜色
        const last = stops[stops.length - 1];
        return `rgb(${last.color[0]}, ${last.color[1]}, ${last.color[2]})`;
      }

      function computeValueRatio(value, min, max) {
        // Guard against invalid numbers and degenerate ranges / 先排除无效数字或相等边界
        if (!Number.isFinite(value) || !Number.isFinite(min) || !Number.isFinite(max) || min === max) {
          return null;
        }
        // Snap to bounds when value is outside / 当值越界时直接归到上下限
        if (value <= min) {
          return 0;
        }
        if (value >= max) {
          return 1;
        }
        // Normalize within [0,1] for downstream coloring / 将区间映射到 [0,1] 便于着色
        return (value - min) / (max - min);
      }

      function valueToColor(value, min, max) {
        // Empty cells use muted gray / 缺失值使用灰色
        if (!Number.isFinite(value)) {
          return "#dee2e6";
        }
        // Without a valid range, default to base green / 没有有效范围时使用基础绿色
        if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) {
          return toRgbString(COLOR_GREEN);
        }
        if (value <= min) {
          return toRgbString(COLOR_GREEN);
        }
        if (value >= max) {
          return toRgbString(COLOR_RED);
        }
        // Map value into gradient spectrum / 将数值映射到渐变色谱
        const ratio = (value - min) / (max - min);
        return interpolateGradient(GRADIENT_STOPS, ratio);
      }

      function valueToTextColor(value, min, max) {
        // Default to dark text when ratio cannot be computed / 无法计算比值时默认使用深色字体
        const ratio = computeValueRatio(value, min, max);
        if (ratio === null) {
          return "#212529";
        }
        // Use white text on high intensity cells for readability / 对高强度色块使用白字以增强可读性
        return ratio >= 0.75 ? "#ffffff" : "#212529";
      }

      function formatPressureValue(value) {
        // Drop fractional part for display clarity / 去掉小数部分以便阅读
        return Math.trunc(value);
      }

      function applyMirroring(values, rows, cols, options = {}) {
        const mirrorRowsFlag = Boolean(options.mirrorRows);
        const mirrorColsFlag = Boolean(options.mirrorCols);
        // Without full dimensions simply clone the provided values / 没有完整行列信息时直接克隆原始数组
        if (!rows || !cols) {
          return values.slice();
        }
        const result = [];
        for (let displayRow = 0; displayRow < rows; displayRow += 1) {
          // Flip row index when mirrorRows is enabled / 启用行镜像时翻转行索引
          const sourceRow = mirrorRowsFlag ? rows - 1 - displayRow : displayRow;
          const start = sourceRow * cols;
          const rowValues = values.slice(start, start + cols);
          if (mirrorColsFlag) {
            // Reverse cell order horizontally when requested / 需要列镜像时水平翻转
            rowValues.reverse();
          }
          result.push(...rowValues);
        }
        return result;
      }

      function persistMirrorSettings(panel) {
        if (!panel || !panel.selectedDevice) {
          return;
        }
        mirrorSettingsByDevice.set(panel.selectedDevice, {
          rows: panel.mirrorRows,
          cols: panel.mirrorCols
        });
      }

      function syncPanelMirrorControls(panel) {
        if (!panel) {
          return;
        }
        const settings = panel.selectedDevice ? mirrorSettingsByDevice.get(panel.selectedDevice) : null;
        panel.mirrorRows = settings ? Boolean(settings.rows) : false;
        panel.mirrorCols = settings ? Boolean(settings.cols) : false;
        if (panel.mirrorRowsToggle) {
          panel.mirrorRowsToggle.checked = panel.mirrorRows;
          panel.mirrorRowsToggle.disabled = !panel.selectedDevice || !panelIsActive(panel);
        }
        if (panel.mirrorColsToggle) {
          panel.mirrorColsToggle.checked = panel.mirrorCols;
          panel.mirrorColsToggle.disabled = !panel.selectedDevice || !panelIsActive(panel);
        }
      }

      function setPanelPlaceholder(panel, key) {
        if (!panel || !panel.heatmapContainer) {
          return;
        }
        panel.heatmapContainer.innerHTML = `<div class="heatmap-placeholder">${t(key)}</div>`;
      }

      function buildPanelRenderContext(panel) {
        if (!panelIsActive(panel)) {
          return { state: "inactive" };
        }
        if (!panel || !panel.heatmapContainer) {
          return { state: "missing" };
        }
        if (!panel.selectedDevice) {
          return { state: "no_device" };
        }
        const entry = state.get(panel.selectedDevice);
        if (!entry) {
          return { state: "waiting" };
        }
        const layout = parseLayoutKey(panel.selectedLayoutKey);
        if (!layout) {
          return { state: "no_layout" };
        }
        const [rows, cols] = layout;
        const totalCells = rows * cols;
        const values = Array.isArray(entry.pressureValues) ? entry.pressureValues.slice(0, totalCells) : [];
        while (values.length < totalCells) {
          values.push(NaN);
        }
        const displayValues = applyMirroring(values, rows, cols, {
          mirrorRows: panel.mirrorRows,
          mirrorCols: panel.mirrorCols
        });
        const validValues = values.filter((value) => Number.isFinite(value));
        const hasValidValues = validValues.length > 0;
        const dataMin = hasValidValues ? Math.min(...validValues) : null;
        const dataMax = hasValidValues ? Math.max(...validValues) : null;
        return {
          state: "ready",
          rows,
          cols,
          displayValues,
          dataMin,
          dataMax
        };
      }

      function renderPanelHeatmap(panel, ctx, range) {
        if (!panel || !panel.heatmapContainer) {
          return;
        }
        const container = panel.heatmapContainer;
        container.innerHTML = "";
        if (!ctx || ctx.state === "missing") {
          container.innerHTML = "";
          return;
        }
        if (ctx.state === "inactive") {
          setPanelPlaceholder(panel, "heatmap.empty.dual_disabled");
          return;
        }
        if (ctx.state !== "ready") {
          const placeholderKey =
            ctx.state === "no_device"
              ? "heatmap.empty.no_device"
              : ctx.state === "no_layout"
                ? "heatmap.empty.no_layout"
                : "heatmap.empty.waiting";
          setPanelPlaceholder(panel, placeholderKey);
          return;
        }
        const grid = document.createElement("div");
        grid.className = "heatmap-grid";
        grid.style.setProperty("--rows", ctx.rows);
        grid.style.setProperty("--cols", ctx.cols);
        const min = Number.isFinite(range.min) ? range.min : 0;
        const max = Number.isFinite(range.max) ? range.max : min;
        ctx.displayValues.forEach((value) => {
          const cell = document.createElement("div");
          cell.className = "heatmap-cell";
          if (Number.isFinite(value)) {
            const displayValue = formatPressureValue(value);
            cell.textContent = displayValue;
            cell.style.backgroundColor = valueToColor(value, min, max);
            cell.style.color = valueToTextColor(value, min, max);
            cell.title = `${t("heatmap.tooltip.value")}${displayValue}`;
          } else {
            cell.classList.add("is-empty");
            cell.textContent = "--";
            cell.title = t("heatmap.tooltip.missing");
          }
          grid.appendChild(cell);
        });
        container.appendChild(grid);
      }

      function updateAllHeatmaps() {
        const panelData = panelContexts.map((panel) => {
          if (!panelIsActive(panel)) {
            return { panel, ctx: { state: "inactive" } };
          }
          return { panel, ctx: buildPanelRenderContext(panel) };
        });
        const mins = panelData
          .filter(({ ctx }) => ctx && ctx.state === "ready" && Number.isFinite(ctx.dataMin))
          .map(({ ctx }) => ctx.dataMin);
        const maxs = panelData
          .filter(({ ctx }) => ctx && ctx.state === "ready" && Number.isFinite(ctx.dataMax))
          .map(({ ctx }) => ctx.dataMax);
        const dataMin = mins.length ? Math.min(...mins) : null;
        const dataMax = maxs.length ? Math.max(...maxs) : null;
        updateRangePlaceholders(dataMin, dataMax);
        const range = resolveEffectiveRange(dataMin, dataMax);
        panelData.forEach(({ panel, ctx }) => {
          renderPanelHeatmap(panel, ctx, range);
        });
      }

      function chooseDefaultDeviceForPanel(panel, devices) {
        if (panel.selectedDevice && devices.includes(panel.selectedDevice)) {
          return panel.selectedDevice;
        }
        if (panel.key === "secondary") {
          const primaryDn = primaryPanel?.selectedDevice || null;
          const alternate = devices.find((dn) => dn !== primaryDn);
          if (alternate) {
            return alternate;
          }
        }
        return devices[0] || null;
      }

      function updateLayoutOptionsForPanel(panel) {
        if (!panel || !panel.layoutSelector) {
          return;
        }
        if (!panelIsActive(panel)) {
          panel.layoutSelector.innerHTML = "";
          panel.layoutSelector.disabled = true;
          panel.layoutSelector.value = "";
          panel.selectedLayoutKey = null;
          if (panel.mirrorRowsToggle) {
            panel.mirrorRowsToggle.disabled = true;
            panel.mirrorRowsToggle.checked = false;
          }
          if (panel.mirrorColsToggle) {
            panel.mirrorColsToggle.disabled = true;
            panel.mirrorColsToggle.checked = false;
          }
          panel.layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: currentLanguage };
          setPanelPlaceholder(panel, "heatmap.empty.dual_disabled");
          return;
        }
        const entry = panel.selectedDevice ? state.get(panel.selectedDevice) : null;
        if (panel.mirrorRowsToggle) {
          panel.mirrorRowsToggle.disabled = true;
        }
        if (panel.mirrorColsToggle) {
          panel.mirrorColsToggle.disabled = true;
        }
        if (!entry) {
          panel.layoutSelector.innerHTML = "";
          panel.layoutSelector.disabled = true;
          panel.layoutSelector.value = "";
          panel.selectedLayoutKey = null;
          panel.layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: currentLanguage };
          setPanelPlaceholder(panel, panel.selectedDevice ? "heatmap.empty.waiting" : "heatmap.empty.no_device");
          return;
        }
        const sensorCount = Number.isInteger(entry.sensorCount)
          ? entry.sensorCount
          : Array.isArray(entry.pressureValues)
            ? entry.pressureValues.length
            : 0;
        const pairs = computeFactorPairs(sensorCount);
        if (!pairs.length) {
          panel.layoutSelector.innerHTML = "";
          panel.layoutSelector.disabled = true;
          panel.selectedLayoutKey = null;
          panel.layoutOptionsCache = { dn: entry.dn, sensorCount, options: [], selectedKey: null, lang: currentLanguage };
          setPanelPlaceholder(panel, "heatmap.empty.no_layout");
          return;
        }
        const optionKeys = pairs.map(([rows, cols]) => `${rows}x${cols}`);
        const languageChanged = panel.layoutOptionsCache.lang !== currentLanguage;
        const optionsChanged =
          panel.layoutOptionsCache.dn !== entry.dn ||
          panel.layoutOptionsCache.sensorCount !== sensorCount ||
          !arraysEqual(optionKeys, panel.layoutOptionsCache.options) ||
          languageChanged;
        if (optionsChanged) {
          panel.layoutSelector.innerHTML = "";
          pairs.forEach(([rows, cols]) => {
            const key = `${rows}x${cols}`;
            const option = document.createElement("option");
            option.value = key;
            option.textContent = `${rows} × ${cols}`;
            panel.layoutSelector.appendChild(option);
          });
        }
        if (!panel.selectedLayoutKey || !optionKeys.includes(panel.selectedLayoutKey)) {
          panel.selectedLayoutKey =
            panel.layoutOptionsCache.selectedKey && optionKeys.includes(panel.layoutOptionsCache.selectedKey)
              ? panel.layoutOptionsCache.selectedKey
              : chooseDefaultLayout(pairs);
        }
        panel.layoutSelector.value = panel.selectedLayoutKey || "";
        panel.layoutSelector.disabled = false;
        if (panel.mirrorRowsToggle) {
          panel.mirrorRowsToggle.disabled = false;
        }
        if (panel.mirrorColsToggle) {
          panel.mirrorColsToggle.disabled = false;
        }
        syncPanelMirrorControls(panel);
        panel.layoutOptionsCache = {
          dn: entry.dn,
          sensorCount,
          options: optionKeys,
          selectedKey: panel.selectedLayoutKey,
          lang: currentLanguage
        };
      }

      function updateDeviceOptions() {
        const devices = Array.from(state.keys()).sort();
        return updateDeviceOptionsWithList(devices);
      }

      function updateDeviceOptionsWithList(devices) {
        let changed = false;
        panelContexts.forEach((panel) => {
          if (!panel.deviceSelector) {
            return;
          }
          const previousSelection = panel.selectedDevice;
          const listChanged = !arraysEqual(devices, panel.deviceOptionsCache.devices);
          const languageChanged = panel.deviceOptionsCache.lang !== currentLanguage;
          const isActive = panelIsActive(panel);
          if (!devices.length) {
            if (listChanged || languageChanged) {
              panel.deviceSelector.innerHTML = '';
              const option = document.createElement('option');
              option.value = '';
              option.textContent = t('controls.waiting');
              panel.deviceSelector.appendChild(option);
            }
            panel.deviceSelector.disabled = true;
            panel.deviceSelector.value = '';
            panel.selectedDevice = null;
            panel.selectedLayoutKey = null;
            panel.deviceOptionsCache = { devices, selected: null, lang: currentLanguage };
            panel.layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: currentLanguage };
            syncPanelMirrorControls(panel);
            setPanelPlaceholder(panel, isActive ? "heatmap.empty.waiting" : "heatmap.empty.dual_disabled");
            changed = true;
            return;
          }
          if (listChanged || languageChanged) {
            panel.deviceSelector.innerHTML = '';
            devices.forEach((dn) => {
              const option = document.createElement('option');
              option.value = dn;
              option.textContent = dn;
              panel.deviceSelector.appendChild(option);
            });
          }
          if (!panel.selectedDevice || !devices.includes(panel.selectedDevice)) {
            panel.selectedDevice = chooseDefaultDeviceForPanel(panel, devices);
          }
          if (panel.deviceSelector.value !== panel.selectedDevice) {
            panel.deviceSelector.value = panel.selectedDevice || '';
          }
          panel.deviceSelector.disabled = !isActive;
          const selectionChanged = panel.selectedDevice !== previousSelection;
          panel.deviceOptionsCache = { devices, selected: panel.selectedDevice, lang: currentLanguage };
          if (selectionChanged) {
            syncPanelMirrorControls(panel);
          }
          if (listChanged || languageChanged || selectionChanged) {
            changed = true;
          }
        });
        return changed;
      }

      // --- Dashboard summary (active devices only) ---
      // --- 仪表盘概要：仅展示活跃设备 ---
      function updateSummary() {
        // Aggregate active device count based on freshness / 根据数据新鲜度统计活跃设备数量
        const now = Date.now();
        let active = 0;
        for (const entry of state.values()) {
          // Treat entries newer than threshold as active / 将未超过过期阈值的记录视作活跃
          if (entry.receivedAt && now - entry.receivedAt <= STALE_THRESHOLD_MS) {
            active += 1;
          }
        }
        if (activeDevicesLabel) {
          activeDevicesLabel.textContent = active;
        }
      }

      function formatAxisReading(value, options = {}) {
        const scale = Number.isFinite(options.scale) ? options.scale : 1;
        if (!Number.isFinite(value)) {
          return "--";
        }
        const scaled = value * scale;
        const abs = Math.abs(scaled);
        let decimals = 0;
        if (abs < 10) {
          decimals = 2;
        } else if (abs < 100) {
          decimals = 1;
        } else {
          decimals = 0;
        }
        return scaled.toFixed(decimals);
      }

      function updateOverviewSensors() {
        const entry = primaryPanel?.selectedDevice ? state.get(primaryPanel.selectedDevice) : null;
        const gyro = entry && Array.isArray(entry.gyro) ? entry.gyro : null;
        const acc = entry && Array.isArray(entry.acc) ? entry.acc : null;
        ["x", "y", "z"].forEach((axis, idx) => {
          if (gyroElements[axis]) {
            const value = gyro && Number.isFinite(gyro[idx]) ? gyro[idx] : null;
            gyroElements[axis].textContent = value !== null ? formatAxisReading(value) : "--";
          }
          if (accElements[axis]) {
            const accValue = acc && Number.isFinite(acc[idx]) ? acc[idx] : null;
            accElements[axis].textContent =
              accValue !== null ? formatAxisReading(accValue, { scale: 9.8 }) : "--";
          }
        });
        if (sensorSourceLabel) {
          sensorSourceLabel.textContent = entry && entry.dn ? entry.dn : "--";
        }
      }

      function updateLastUpdateIndicator() {
        // Find latest received timestamp across devices / 查找所有设备中最新的接收时间
        const latest = Array.from(state.values()).reduce(
          (max, entry) => Math.max(max, entry.receivedAt || 0),
          0
        );
        if (lastUpdateLabel) {
          lastUpdateLabel.textContent = latest ? new Date(latest).toLocaleString() : "--";
        }
      }

      function performRefresh() {
        // Reset pending flag before running heavy updates / 在执行耗时刷新前先复位待刷新标记
        pendingRefresh = false;
        lastRefreshTimestamp = Date.now();
        updateSummary();
        updateTable();
        const deviceChanged = updateDeviceOptions();
        panelContexts.forEach((panel) => {
          if (deviceChanged || panel.selectedDevice) {
            updateLayoutOptionsForPanel(panel);
          }
        });
        updateAllHeatmaps();
        updateOverviewSensors();
        updateLastUpdateIndicator();
      }

      function refreshUI() {
        // Debounce expensive refresh cascades / 对昂贵的刷新过程做防抖
        pendingRefresh = true;
        if (refreshTimerId !== null) {
          return;
        }
        const now = Date.now();
        const elapsed = now - lastRefreshTimestamp;
        const delay = Math.max(REFRESH_INTERVAL_MS - elapsed, 0);
        refreshTimerId = window.setTimeout(() => {
          refreshTimerId = null;
          if (!pendingRefresh) {
            return;
          }
          // Execute deferred refresh when timer fires / 定时器触发后执行延迟刷新
          performRefresh();
        }, delay);
      }

      function updateTable() {
        const tbody = document.querySelector("#device-table tbody");
        const now = Date.now();
        // Sort by DN for predictable ordering (locale aware when possible) / 优先按 DN 排序（可用时采用本地化比较）
        const rows = Array.from(state.values()).sort((a, b) => {
          if (a.dn && b.dn && a.dn.localeCompare) {
            return a.dn.localeCompare(b.dn, undefined, { numeric: true, sensitivity: "base" });
          }
          if (a.dn < b.dn) return -1;
          if (a.dn > b.dn) return 1;
          return 0;
        });
        tbody.innerHTML = "";
        const stopLabel = t("table.actions.stop_tracking");
        for (const entry of rows) {
          const tr = document.createElement("tr");
          const isStale = !entry.receivedAt || now - entry.receivedAt > STALE_THRESHOLD_MS;
          if (isStale) {
            // Gray out rows that haven't updated recently / 将长时间未更新的行置灰
            tr.classList.add("text-muted");
          }
          // Format row markup including action button / 生成包含操作按钮的行内容
          tr.innerHTML = `
            <td><code>${entry.dn}</code></td>
            <td>${entry.sensorCount ?? "--"}</td>
            <td>${entry.frameTime ? new Date(entry.frameTime).toLocaleString() : "--"}</td>
            <td>${entry.receivedAt ? new Date(entry.receivedAt).toLocaleString() : "--"}</td>
            <td class="text-center">
              <button type="button" class="btn btn-sm btn-outline-danger remove-device" data-dn="${entry.dn}">${stopLabel}</button>
            </td>
          `;
          const removeButton = tr.querySelector(".remove-device");
          if (removeButton) {
            removeButton.addEventListener("click", (event) => {
              // Stop click from selecting row, then purge device / 阻止事件冒泡后移除该设备
              event.stopPropagation();
              removeDevice(entry.dn);
            });
            removeButton.setAttribute("title", stopLabel);
          }
          tbody.appendChild(tr);
        }
      }

      function removeDevice(dn) {
        // Ignore requests for unknown devices / 忽略未知设备的移除请求
        if (!state.has(dn)) {
          return;
        }
        // Drop device state and any cached mirror preferences / 删除设备状态及其镜像偏好
        state.delete(dn);
        mirrorSettingsByDevice.delete(dn);
        panelContexts.forEach((panel) => {
          if (panel.selectedDevice === dn) {
            panel.selectedDevice = null;
            panel.selectedLayoutKey = null;
            panel.deviceOptionsCache.selected = null;
            panel.layoutOptionsCache = { dn: null, sensorCount: null, options: [], selectedKey: null, lang: currentLanguage };
            if (panel.deviceSelector) {
              panel.deviceSelector.value = "";
            }
            if (panel.layoutSelector) {
              panel.layoutSelector.innerHTML = "";
              panel.layoutSelector.disabled = true;
            }
            syncPanelMirrorControls(panel);
            setPanelPlaceholder(panel, panelIsActive(panel) ? "heatmap.empty.no_device" : "heatmap.empty.dual_disabled");
          }
        });
        // Trigger full UI refresh so dropdown + table update / 触发整体刷新以更新下拉与表格
        refreshUI();
      }

      function normalizeEntry(entry) {
        // Validate payload shape before processing / 在处理前确认负载结构
        if (!entry || typeof entry !== "object") {
          return null;
        }
        const dn = entry.dn || "UNKNOWN";
        const payload = entry.payload || {};
        let pressureSum = null;
        let sensorCount = null;
        let frameTime = null;
        let pressureValues = [];
        let gyroValues = null;
        let accValues = null;
        if (payload && typeof payload === "object") {
          const rawPressures = Array.isArray(payload.p) ? payload.p : [];
          // Coerce every reading into a number (or NaN) / 将每个读数转成数字（或 NaN）
          const numericPressures = rawPressures.map((value) => {
            const num = Number(value);
            return Number.isFinite(num) ? num : NaN;
          });
          const declaredCount = Number(payload.sn);
          if (Number.isInteger(declaredCount) && declaredCount > 0) {
            sensorCount = declaredCount;
          } else {
            sensorCount = numericPressures.length;
          }
          pressureValues = numericPressures.slice(0, sensorCount);
          while (pressureValues.length < sensorCount) {
            // Pad with NaN if payload shorter than declared count / 当数据不足时用 NaN 补齐
            pressureValues.push(NaN);
          }
          // Sum only valid numeric pressures / 仅累加有效的压力值
          pressureSum = pressureValues.reduce(
            (acc, value) => acc + (Number.isFinite(value) ? value : 0),
            0
          );
          if (payload.ts) {
            frameTime = payload.ts * 1000;
          }
          if (Array.isArray(payload.gyro)) {
            const numericGyro = payload.gyro.map((value) => {
              const num = Number(value);
              return Number.isFinite(num) ? num : NaN;
            });
            gyroValues = [
              Number.isFinite(numericGyro[0]) ? numericGyro[0] : NaN,
              Number.isFinite(numericGyro[1]) ? numericGyro[1] : NaN,
              Number.isFinite(numericGyro[2]) ? numericGyro[2] : NaN
            ];
          }
          if (Array.isArray(payload.acc)) {
            const numericAcc = payload.acc.map((value) => {
              const num = Number(value);
              return Number.isFinite(num) ? num : NaN;
            });
            accValues = [
              Number.isFinite(numericAcc[0]) ? numericAcc[0] : NaN,
              Number.isFinite(numericAcc[1]) ? numericAcc[1] : NaN,
              Number.isFinite(numericAcc[2]) ? numericAcc[2] : NaN
            ];
          }
        }
        const receivedAt = entry.received_at ? Date.parse(entry.received_at) : Date.now();
        return {
          dn,
          pressureSum,
          sensorCount,
          frameTime,
          receivedAt,
          pressureValues,
          gyro: gyroValues,
          acc: accValues,
          raw: entry
        };
      }

      function applyEntry(entry, options = {}) {
        // Normalize raw payload into canonical shape / 将原始负载转换成规范结构
        const normalized = normalizeEntry(entry);
        if (!normalized) return;
        state.set(normalized.dn, normalized);
        if (options.defer) {
          // Caller requested to batch updates, so bail / 调用方要求延迟刷新则直接返回
          return;
        }
        // Immediate refresh keeps UI responsive / 立即刷新可保持界面响应
        refreshUI();
      }

      // Fetch periodic snapshots to guard against SSE hiccups.
      // 轮询获取快照，防止 SSE 偶发中断导致数据落后。
      async function fetchSnapshot() {
        try {
          // Pull latest dataset from bridge REST endpoint / 通过桥接 REST 接口拉取最新数据集
          const resp = await fetch(SNAPSHOT_ENDPOINT);
          const data = await resp.json();
          if (Array.isArray(data.data)) {
            // Reuse applyEntry for each snapshot item, deferring refresh for batching / 复用 applyEntry 处理每条快照，并延迟刷新以批量更新
            data.data.forEach((item) => applyEntry(item, { defer: true }));
            refreshUI();
          }
          // Mark snapshot state as healthy and colorize indicator / 将快照状态标记为正常并更新指示器颜色
          setStatusIndicator("snapshot_ok");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-secondary", "bg-danger");
            statusIndicator.classList.add("bg-success");
          }
        } catch (err) {
          // Network or parsing failures push indicator to error state / 网络或解析失败将状态切换为错误
          setStatusIndicator("snapshot_error");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-secondary", "bg-success");
            statusIndicator.classList.add("bg-danger");
          }
          console.error(t("console.snapshot_fetch_failed"), err);
        }
      }

      // Subscribe to bridge SSE stream for near real-time updates.
      // 订阅桥接 SSE 流，实现准实时更新。
      function subscribeStream() {
        // Reset previous SSE connection before opening a new one / 新建 SSE 连接前先清理旧实例
        cleanupEventSource();
        clearStreamReconnectTimer();
        const source = new EventSource(STREAM_ENDPOINT);
        currentEventSource = source;
        setStatusIndicator("connecting");
        if (statusIndicator) {
          statusIndicator.classList.remove("bg-success", "bg-danger", "bg-warning");
          statusIndicator.classList.add("bg-secondary");
        }
        source.addEventListener("snapshot", (event) => {
          try {
            const payload = JSON.parse(event.data);
            if (Array.isArray(payload.data)) {
              // Snapshot events refresh entire dataset / snapshot 事件刷新整套数据
              payload.data.forEach((item) => applyEntry(item, { defer: true }));
              refreshUI();
            }
          } catch (err) {
            console.error(t("console.snapshot_event_error"), err);
          }
        });
        source.addEventListener("update", (event) => {
          try {
            const payload = JSON.parse(event.data);
            // Update events only touch single device / update 事件通常只更新单个设备
            applyEntry(payload);
          } catch (err) {
            console.error(t("console.update_event_error"), err);
          }
        });
        source.addEventListener("error", () => {
          // Switch indicator to warning and attempt graceful recovery / 将指示器切为警告并尝试恢复
          setStatusIndicator("stream_error");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-success");
            statusIndicator.classList.add("bg-warning");
          }
          cleanupEventSource();
          const shouldFetchSnapshot = streamReconnectTimerId === null;
          scheduleStreamReconnect();
          if (shouldFetchSnapshot) {
            // Kick off snapshot fetch so UI doesn't stagnate / 触发快照抓取避免界面停滞
            fetchSnapshot();
          }
        });
        source.onopen = () => {
          // Connected successfully; reset backoff and mark success / 连接成功后重置退避并标为成功
          clearStreamReconnectTimer();
          streamReconnectAttempts = 0;
          setStatusIndicator("stream_ok");
          if (statusIndicator) {
            statusIndicator.classList.remove("bg-secondary", "bg-danger", "bg-warning");
            statusIndicator.classList.add("bg-success");
          }
        };
      }

      applyLanguage();
      performRefresh();
      fetchSnapshot();
      if (snapshotPollTimerId === null) {
        snapshotPollTimerId = window.setInterval(fetchSnapshot, SNAPSHOT_POLL_INTERVAL_MS);
      }
      window.addEventListener("beforeunload", () => {
        cleanupEventSource();
        clearStreamReconnectTimer();
        if (snapshotPollTimerId !== null) {
          window.clearInterval(snapshotPollTimerId);
          snapshotPollTimerId = null;
        }
      });
      subscribeStream();
    </script>
  </body>
</html>
